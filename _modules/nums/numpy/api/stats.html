
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>nums.numpy.api.stats &#8212; NumS  documentation</title>
    
    <link href="../../../../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../../../../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
  
    
    <link rel="stylesheet"
      href="../../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
    <link rel="preload" as="font" type="font/woff2" crossorigin
      href="../../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
    <link rel="preload" as="font" type="font/woff2" crossorigin
      href="../../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">
  
    
      
  
    
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/styles/pydata-sphinx-theme.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/css/nums.css" />
    
    <link rel="preload" as="script" href="../../../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">
  
    <script id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    
      
      <link rel="icon" sizes="16x16" href="../../../../_static/icon.svg">
      
    
      
      <link rel="icon" sizes="32x32" href="../../../../_static/icon.svg">
      
    
      
      <link rel="apple-touch-icon" sizes="180x180" href="../../../../_static/apple-touch-icon-180x180.png">
      
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    

<a class="navbar-brand" href="../../../../index.html">
  <img src="../../../../_static/logo.svg" class="logo" alt="logo">
</a>


    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../get_started/index.html">
  Get Started
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../user_guide/index.html">
  User Guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../reference/index.html">
  API Reference
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../development/index.html">
  Development
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/nums-project/nums" rel="noopener" target="_blank" title="GitHub"><span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://twitter.com/kanyewest" rel="noopener" target="_blank" title="Twitter"><span><i class="fab fa-twitter-square"></i></span>
            <label class="sr-only">Twitter</label></a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar">
              <div class="sidebar-start-items"><form class="bd-search d-flex align-items-center" action="../../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
              </div>
              <div class="sidebar-end-items">
              </div>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <h1>Source code for nums.numpy.api.stats</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (C) 2020 NumS Development Team.</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>

<span class="c1"># pylint: disable = redefined-builtin, too-many-lines, anomalous-backslash-in-string, unused-wildcard-import, wildcard-import</span>

<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">from</span> <span class="nn">nums.core.application_manager</span> <span class="kn">import</span> <span class="n">instance</span> <span class="k">as</span> <span class="n">_instance</span>
<span class="kn">from</span> <span class="nn">nums.core.array.blockarray</span> <span class="kn">import</span> <span class="n">BlockArray</span>

<span class="kn">from</span> <span class="nn">nums.numpy.api.arithmetic</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">nums.numpy.api.generated</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c1">############################################</span>
<span class="c1"># Stats</span>
<span class="c1">############################################</span>


<div class="viewcode-block" id="average"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.average.html#nums.numpy.api.stats.average">[docs]</a><span class="k">def</span> <span class="nf">average</span><span class="p">(</span>
    <span class="n">a</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">weights</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">BlockArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">returned</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">BlockArray</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">BlockArray</span><span class="p">,</span> <span class="n">BlockArray</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;Compute the weighted average along the specified axis.</span>

<span class="sd">    This docstring was copied from numpy.average.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Compute the weighted average along the specified axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : BlockArray</span>
<span class="sd">        Array containing data to be averaged. If `a` is not an array, a</span>
<span class="sd">        conversion is attempted.</span>
<span class="sd">    axis : None or int or tuple of ints, optional</span>
<span class="sd">        Axis or axes along which to average `a`.  The default,</span>
<span class="sd">        axis=None, will average over all of the elements of the input array.</span>
<span class="sd">        If axis is negative it counts from the last to the first axis.</span>
<span class="sd">        If axis is a tuple of ints, averaging is performed on all of the axes</span>
<span class="sd">        specified in the tuple instead of a single axis or all the axes as</span>
<span class="sd">        before.</span>
<span class="sd">    weights : BlockArray, optional</span>
<span class="sd">        An array of weights associated with the values in `a`. Each value in</span>
<span class="sd">        `a` contributes to the average according to its associated weight.</span>
<span class="sd">        The weights array can either be 1-D (in which case its length must be</span>
<span class="sd">        the size of `a` along the given axis) or of the same shape as `a`.</span>
<span class="sd">        If `weights=None`, then all data in `a` are assumed to have a</span>
<span class="sd">        weight equal to one.  The 1-D calculation is::</span>

<span class="sd">            avg = sum(a * weights) / sum(weights)</span>

<span class="sd">        The only constraint on `weights` is that `sum(weights)` must not be 0.</span>
<span class="sd">    returned : bool, optional</span>
<span class="sd">        Default is `False`. If `True`, the tuple (`average`, `sum_of_weights`)</span>
<span class="sd">        is returned, otherwise only the average is returned.</span>
<span class="sd">        If `weights=None`, `sum_of_weights` is equivalent to the number of</span>
<span class="sd">        elements over which the average is taken.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    retval, [sum_of_weights] : array_type or double</span>
<span class="sd">        Return the average along the specified axis. When `returned` is `True`,</span>
<span class="sd">        return a tuple with the average as the first element and the sum</span>
<span class="sd">        of the weights as the second element. `sum_of_weights` is of the</span>
<span class="sd">        same type as `retval`. The result dtype follows a genereal pattern.</span>
<span class="sd">        If `weights` is None, the result dtype will be that of `a` , or ``float64``</span>
<span class="sd">        if `a` is integral. Otherwise, if `weights` is not None and `a` is non-</span>
<span class="sd">        integral, the result type will be the type of lowest precision capable of</span>
<span class="sd">        representing values of both `a` and `weights`. If `a` happens to be</span>
<span class="sd">        integral, the previous rules still applies but the result dtype will</span>
<span class="sd">        at least be ``float``.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ZeroDivisionError</span>
<span class="sd">        When all weights along axis are zero. See `numpy.ma.average` for a</span>
<span class="sd">        version robust to this type of error.</span>
<span class="sd">    TypeError</span>
<span class="sd">        When the length of 1D `weights` is not the same as the shape of `a`</span>
<span class="sd">        along axis.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    mean</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Only single &#39;axis&#39; is currently supported.</span>

<span class="sd">    1D weights broadcasting is currently not supported.</span>

<span class="sd">    Weights along one or more axes sum to zero.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; data = nps.arange(1, 5)  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; data.get()  # doctest: +SKIP</span>
<span class="sd">    array([1, 2, 3, 4])</span>
<span class="sd">    &gt;&gt;&gt; nps.average(data).get()  # doctest: +SKIP</span>
<span class="sd">    array(2.5)</span>

<span class="sd">    &gt;&gt;&gt; data = nps.arange(6).reshape((3,2))  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; data.get()  # doctest: +SKIP</span>
<span class="sd">    array([[0, 1],</span>
<span class="sd">           [2, 3],</span>
<span class="sd">           [4, 5]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Only single &#39;axis&#39; is currently supported.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">avg</span> <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">returned</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">avg</span>
        <span class="n">weights_sum</span> <span class="o">=</span> <span class="n">BlockArray</span><span class="o">.</span><span class="n">from_scalar</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">size</span> <span class="o">/</span> <span class="n">avg</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">cm</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">avg</span><span class="p">,</span> <span class="n">weights_sum</span>

    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">weights</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;1D weights broadcasting is currently not supported; &quot;</span>
            <span class="s2">&quot;dimensions of &#39;a&#39; and &#39;weights&#39; must match.&quot;</span>
        <span class="p">)</span>
    <span class="n">weights_sum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">weights_sum</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ZeroDivisionError</span><span class="p">(</span><span class="s2">&quot;Weights along one or more axes sum to zero.&quot;</span><span class="p">)</span>
    <span class="n">avg</span> <span class="o">=</span> <span class="n">divide</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">multiply</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">weights</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">),</span> <span class="n">weights_sum</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">returned</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">avg</span>
    <span class="k">if</span> <span class="n">avg</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">weights_sum</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="n">weights_sum</span> <span class="o">=</span> <span class="n">weights_sum</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">avg</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">avg</span><span class="p">,</span> <span class="n">weights_sum</span></div>


<div class="viewcode-block" id="cov"><a class="viewcode-back" href="../../../../generated/nums.numpy.api.stats.html#nums.numpy.api.stats.cov">[docs]</a><span class="k">def</span> <span class="nf">cov</span><span class="p">(</span>
    <span class="n">m</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span>
    <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">rowvar</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">ddof</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">fweights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">aweights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Estimate a covariance matrix, given data and weights.</span>

<span class="sd">    This docstring was copied from numpy.cov.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Covariance indicates the level to which two variables vary together.</span>
<span class="sd">    If we examine N-dimensional samples, :math:`X = [x_1, x_2, ... x_N]^T`,</span>
<span class="sd">    then the covariance matrix element :math:`C_{ij}` is the covariance of</span>
<span class="sd">    :math:`x_i` and :math:`x_j`. The element :math:`C_{ii}` is the variance</span>
<span class="sd">    of :math:`x_i`.</span>

<span class="sd">    See the notes for an outline of the algorithm.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m : BlockArray</span>
<span class="sd">        A 1-D or 2-D array containing multiple variables and observations.</span>
<span class="sd">        Each row of `m` represents a variable, and each column a single</span>
<span class="sd">        observation of all those variables. Also see `rowvar` below.</span>
<span class="sd">    y : BlockArray, optional</span>
<span class="sd">        An additional set of variables and observations. `y` has the same form</span>
<span class="sd">        as that of `m`.</span>
<span class="sd">    rowvar : bool, optional</span>
<span class="sd">        If `rowvar` is True (default), then each row represents a</span>
<span class="sd">        variable, with observations in the columns. Otherwise, the relationship</span>
<span class="sd">        is transposed: each column represents a variable, while the rows</span>
<span class="sd">        contain observations.</span>
<span class="sd">    bias : bool, optional</span>
<span class="sd">        Default normalization (False) is by ``(N - 1)``, where ``N`` is the</span>
<span class="sd">        number of observations given (unbiased estimate). If `bias` is True,</span>
<span class="sd">        then normalization is by ``N``. These values can be overridden by using</span>
<span class="sd">        the keyword ``ddof`` in numpy versions &gt;= 1.5.</span>
<span class="sd">    ddof : int, optional</span>
<span class="sd">        If not ``None`` the default value implied by `bias` is overridden.</span>
<span class="sd">        Note that ``ddof=1`` will return the unbiased estimate, even if both</span>
<span class="sd">        `fweights` and `aweights` are specified, and ``ddof=0`` will return</span>
<span class="sd">        the simple average. See the notes for the details. The default value</span>
<span class="sd">        is ``None``.</span>
<span class="sd">    fweights : BlockArray, int, optional</span>
<span class="sd">        1-D array of integer frequency weights; the number of times each</span>
<span class="sd">        observation vector should be repeated.</span>
<span class="sd">    aweights : BlockArray, optional</span>
<span class="sd">        1-D array of observation vector weights. These relative weights are</span>
<span class="sd">        typically large for observations considered &quot;important&quot; and smaller for</span>
<span class="sd">        observations considered less &quot;important&quot;. If ``ddof=0`` the array of</span>
<span class="sd">        weights can be used to assign probabilities to observation vectors.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : BlockArray</span>
<span class="sd">        The covariance matrix of the variables.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    corrcoef : Normalized covariance matrix</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Assume that the observations are in the columns of the observation</span>
<span class="sd">    array `m` and let ``f = fweights`` and ``a = aweights`` for brevity. The</span>
<span class="sd">    steps to compute the weighted covariance are as follows::</span>

<span class="sd">        &gt;&gt;&gt; m = nps.arange(10, dtype=nps.float64)  # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; f = nps.arange(10) * 2  # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; a = nps.arange(10) ** 2.  # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; ddof = 1  # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; w = f * a  # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; v1 = nps.sum(w)  # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; v2 = nps.sum(w * a)  # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; m -= nps.sum(m * w, axis=None, keepdims=True) / v1  # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; cov = nps.dot(m * w, m.T) * v1 / (v1**2 - ddof * v2)  # doctest: +SKIP</span>

<span class="sd">    Note that when ``a == 1``, the normalization factor</span>
<span class="sd">    ``v1 / (v1**2 - ddof * v2)`` goes over to ``1 / (nps.sum(f) - ddof).get()``</span>
<span class="sd">    as it should.</span>

<span class="sd">    y, ddof, fweights, and aweights are not supported.</span>

<span class="sd">    Only 2-dimensional arrays are supported.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    Consider two variables, :math:`x_0` and :math:`x_1`, which</span>
<span class="sd">    correlate perfectly, but in opposite directions:</span>

<span class="sd">    &gt;&gt;&gt; x = nps.array([[0, 2], [1, 1], [2, 0]]).T  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; x.get()  # doctest: +SKIP</span>
<span class="sd">    array([[0, 1, 2],</span>
<span class="sd">           [2, 1, 0]])</span>

<span class="sd">    Note how :math:`x_0` increases while :math:`x_1` decreases. The covariance</span>
<span class="sd">    matrix shows this clearly:</span>

<span class="sd">    &gt;&gt;&gt; nps.cov(x).get()  # doctest: +SKIP</span>
<span class="sd">    array([[ 1., -1.],</span>
<span class="sd">           [-1.,  1.]])</span>

<span class="sd">    Note that element :math:`C_{0,1}`, which shows the correlation between</span>
<span class="sd">    :math:`x_0` and :math:`x_1`, is negative.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ddof</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">fweights</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">aweights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;y, ddof, fweights, and aweights are not supported.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Only 2-dimensional arrays are supported.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">rowvar</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span></div>


<div class="viewcode-block" id="mean"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.mean.html#nums.numpy.api.stats.mean">[docs]</a><span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the arithmetic mean along the specified axis.</span>

<span class="sd">    This docstring was copied from numpy.mean.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : BlockArray</span>
<span class="sd">        Array containing numbers whose mean is desired. If `a` is not an</span>
<span class="sd">        array, a conversion is attempted.</span>
<span class="sd">    axis : None or int or tuple of ints, optional</span>
<span class="sd">        Axis or axes along which the means are computed. The default is to</span>
<span class="sd">        compute the mean of the flattened array.</span>
<span class="sd">        If this is a tuple of ints, a mean is performed over multiple axes,</span>
<span class="sd">        instead of a single axis or all the axes as before.</span>
<span class="sd">    dtype : data-type, optional</span>
<span class="sd">        Type to use in computing the mean.  For integer inputs, the default</span>
<span class="sd">        is `float64`; for floating point inputs, it is the same as the</span>
<span class="sd">        input dtype.</span>
<span class="sd">    out : BlockArray, optional</span>
<span class="sd">        Alternate output array in which to place the result.  The default</span>
<span class="sd">        is ``None``; if provided, it must have the same shape as the</span>
<span class="sd">        expected output, but the type will be cast if necessary.</span>
<span class="sd">        See `ufuncs-output-type` for more details.</span>
<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left</span>
<span class="sd">        in the result as dimensions with size one. With this option,</span>
<span class="sd">        the result will broadcast correctly against the input array.</span>
<span class="sd">        If the default value is passed, then `keepdims` will not be</span>
<span class="sd">        passed through to the `mean` method of sub-classes of</span>
<span class="sd">        `BlockArray`, however any non-default value will be.  If the</span>
<span class="sd">        sub-class&#39; method does not implement `keepdims` any</span>
<span class="sd">        exceptions will be raised.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    m : BlockArray, see dtype parameter above</span>
<span class="sd">        If `out=None`, returns a new array containing the mean values,</span>
<span class="sd">        otherwise a reference to the output array is returned.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    average : Weighted average</span>
<span class="sd">    std, var, nanmean, nanstd, nanvar</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The arithmetic mean is the sum of the elements along the axis divided</span>
<span class="sd">    by the number of elements.</span>

<span class="sd">    Note that for floating-point input, the mean is computed using the</span>
<span class="sd">    same precision the input has.  Depending on the input data, this can</span>
<span class="sd">    cause the results to be inaccurate, especially for `float32` (see</span>
<span class="sd">    example below).  Specifying a higher-precision accumulator using the</span>
<span class="sd">    `dtype` keyword can alleviate this issue.</span>

<span class="sd">    By default, `float16` results are computed using `float32` intermediates</span>
<span class="sd">    for extra precision.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; a = nps.array([[1, 2], [3, 4]])  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; nps.mean(a).get()  # doctest: +SKIP</span>
<span class="sd">    array(2.5)</span>
<span class="sd">    &gt;&gt;&gt; nps.mean(a, axis=0).get()  # doctest: +SKIP</span>
<span class="sd">    array([2., 3.])</span>
<span class="sd">    &gt;&gt;&gt; nps.mean(a, axis=1).get()  # doctest: +SKIP</span>
<span class="sd">    array([1.5, 3.5])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;&#39;out&#39; is currently not supported.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span></div>


<div class="viewcode-block" id="median"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.median.html#nums.numpy.api.stats.median">[docs]</a><span class="k">def</span> <span class="nf">median</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Compute the median along the specified axis.</span>

<span class="sd">    This docstring was copied from numpy.median.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Returns the median of the array elements.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : BlockArray</span>
<span class="sd">        Input array or object that can be converted to an array.</span>
<span class="sd">    axis : {int, sequence of int, None}, optional</span>
<span class="sd">        Axis or axes along which the medians are computed. The default</span>
<span class="sd">        is to compute the median along a flattened version of the array.</span>
<span class="sd">    out : BlockArray, optional</span>
<span class="sd">        Alternative output array in which to place the result. It must</span>
<span class="sd">        have the same shape and buffer length as the expected output,</span>
<span class="sd">        but the type (of the output) will be cast if necessary.</span>
<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left</span>
<span class="sd">        in the result as dimensions with size one. With this option,</span>
<span class="sd">        the result will broadcast correctly against the original `arr`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    median : BlockArray</span>
<span class="sd">        A new array holding the result. If the input contains integers</span>
<span class="sd">        or floats smaller than ``float64``, then the output data-type is</span>
<span class="sd">        ``nps.float64``.  Otherwise, the data-type of the output is the</span>
<span class="sd">        same as that of the input. If `out` is specified, that array is</span>
<span class="sd">        returned instead.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    mean, percentile</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Given a vector ``V`` of length ``N``, the median of ``V`` is the</span>
<span class="sd">    middle value of a sorted copy of ``V``, ``V_sorted`` - i</span>
<span class="sd">    e., ``V_sorted[(N-1)/2]``, when ``N`` is odd, and the average of the</span>
<span class="sd">    two middle values of ``V_sorted`` when ``N`` is even.</span>

<span class="sd">    &#39;axis&#39; is currently not supported.</span>

<span class="sd">    &#39;out&#39; is currently not supported.</span>

<span class="sd">    &#39;keepdims&#39; is currently not supported.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;&#39;axis&#39; is currently not supported.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;&#39;out&#39; is currently not supported.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">keepdims</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;&#39;keepdims&#39; is currently not supported.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></div>


<div class="viewcode-block" id="percentile"><a class="viewcode-back" href="../../../../generated/nums.numpy.api.stats.html#nums.numpy.api.stats.percentile">[docs]</a><span class="k">def</span> <span class="nf">percentile</span><span class="p">(</span>
    <span class="n">a</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span>
    <span class="n">q</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">overwrite_input</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">interpolation</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;linear&quot;</span><span class="p">}</span> <span class="o">=</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Compute the q-th percentile of the data along the specified axis.</span>

<span class="sd">    This docstring was copied from numpy.percentile.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Returns the q-th percentile(s) of the array elements.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : BlockArray</span>
<span class="sd">        Input array or object that can be converted to an array.</span>
<span class="sd">    q : float</span>
<span class="sd">        Percentile or sequence of percentiles to compute, which must be between</span>
<span class="sd">        0 and 100 inclusive.</span>
<span class="sd">    axis : {int, tuple of int, None}, optional</span>
<span class="sd">        Axis or axes along which the percentiles are computed. The</span>
<span class="sd">        default is to compute the percentile(s) along a flattened</span>
<span class="sd">        version of the array.</span>
<span class="sd">    out : BlockArray, optional</span>
<span class="sd">        Alternative output array in which to place the result. It must</span>
<span class="sd">        have the same shape and buffer length as the expected output,</span>
<span class="sd">        but the type (of the output) will be cast if necessary.</span>
<span class="sd">    overwrite_input : bool, optional</span>
<span class="sd">        If True, then allow the input array `a` to be modified by intermediate</span>
<span class="sd">        calculations, to save memory. In this case, the contents of the input</span>
<span class="sd">        `a` after this function completes is undefined.</span>
<span class="sd">    interpolation : {&#39;linear&#39;, &#39;lower&#39;, &#39;higher&#39;, &#39;midpoint&#39;, &#39;nearest&#39;}</span>
<span class="sd">        This optional parameter specifies the interpolation method to</span>
<span class="sd">        use when the desired percentile lies between two data points</span>
<span class="sd">        ``i &lt; j``:</span>

<span class="sd">        * &#39;linear&#39;: ``i + (j - i) * fraction``, where ``fraction``</span>
<span class="sd">          is the fractional part of the index surrounded by ``i``</span>
<span class="sd">          and ``j``.</span>
<span class="sd">        * &#39;lower&#39;: ``i``.</span>
<span class="sd">        * &#39;higher&#39;: ``j``.</span>
<span class="sd">        * &#39;nearest&#39;: ``i`` or ``j``, whichever is nearest.</span>
<span class="sd">        * &#39;midpoint&#39;: ``(i + j) / 2``.</span>
<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left in</span>
<span class="sd">        the result as dimensions with size one. With this option, the</span>
<span class="sd">        result will broadcast correctly against the original array `a`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    percentile : BlockArray</span>
<span class="sd">        If `q` is a single percentile and `axis=None`, then the result</span>
<span class="sd">        is a scalar. If multiple percentiles are given, first axis of</span>
<span class="sd">        the result corresponds to the percentiles. The other axes are</span>
<span class="sd">        the axes that remain after the reduction of `a`. If the input</span>
<span class="sd">        contains integers or floats smaller than ``float64``, the output</span>
<span class="sd">        data-type is ``float64``. Otherwise, the output data-type is the</span>
<span class="sd">        same as that of the input. If `out` is specified, that array is</span>
<span class="sd">        returned instead.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    mean</span>
<span class="sd">    median : equivalent to ``percentile(..., 50)``</span>
<span class="sd">    nanpercentile</span>
<span class="sd">    quantile : equivalent to percentile, except with q in the range [0, 1].</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Given a vector ``V`` of length ``N``, the q-th percentile of</span>
<span class="sd">    ``V`` is the value ``q/100`` of the way from the minimum to the</span>
<span class="sd">    maximum in a sorted copy of ``V``. The values and distances of</span>
<span class="sd">    the two nearest neighbors as well as the `interpolation` parameter</span>
<span class="sd">    will determine the percentile if the normalized ranking does not</span>
<span class="sd">    match the location of ``q`` exactly. This function is the same as</span>
<span class="sd">    the median if ``q=50``, the same as the minimum if ``q=0`` and the</span>
<span class="sd">    same as the maximum if ``q=100``.</span>

<span class="sd">    &#39;axis&#39; is currently not supported.</span>

<span class="sd">    &#39;out&#39; is currently not supported.</span>

<span class="sd">    &#39;overwrite_input&#39; is currently not supported.</span>

<span class="sd">    only &#39;linear&#39; &#39;interpolation&#39; is currently supported.</span>

<span class="sd">    &#39;keepdims&#39; is currently not supported.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; a = nps.array([[10, 7, 4], [3, 2, 1]])  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; a.get()  # doctest: +SKIP</span>
<span class="sd">    array([[10,  7,  4],</span>
<span class="sd">           [ 3,  2,  1]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;&#39;axis&#39; is currently not supported.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;&#39;out&#39; is currently not supported.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">overwrite_input</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;&#39;overwrite_input&#39; is currently not supported.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">interpolation</span> <span class="o">!=</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;only &#39;linear&#39; &#39;interpolation&#39; is currently supported.&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">keepdims</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;&#39;keepdims&#39; is currently not supported.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">interpolation</span><span class="p">)</span></div>


<div class="viewcode-block" id="quantile"><a class="viewcode-back" href="../../../../generated/nums.numpy.api.stats.html#nums.numpy.api.stats.quantile">[docs]</a><span class="k">def</span> <span class="nf">quantile</span><span class="p">(</span>
    <span class="n">a</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span>
    <span class="n">q</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">overwrite_input</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">interpolation</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;linear&quot;</span><span class="p">}</span> <span class="o">=</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Compute the q-th quantile of the data along the specified axis.</span>

<span class="sd">    This docstring was copied from numpy.quantile.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : BlockArray</span>
<span class="sd">        Input array or object that can be converted to an array.</span>
<span class="sd">    q : BlockArray of float</span>
<span class="sd">        Quantile or sequence of quantiles to compute, which must be between</span>
<span class="sd">        0 and 1 inclusive.</span>
<span class="sd">    axis : {int, tuple of int, None}, optional</span>
<span class="sd">        Axis or axes along which the quantiles are computed. The</span>
<span class="sd">        default is to compute the quantile(s) along a flattened</span>
<span class="sd">        version of the array.</span>
<span class="sd">    out : BlockArray, optional</span>
<span class="sd">        Alternative output array in which to place the result. It must</span>
<span class="sd">        have the same shape and buffer length as the expected output,</span>
<span class="sd">        but the type (of the output) will be cast if necessary.</span>
<span class="sd">    overwrite_input : bool, optional</span>
<span class="sd">        If True, then allow the input array `a` to be modified by intermediate</span>
<span class="sd">        calculations, to save memory. In this case, the contents of the input</span>
<span class="sd">        `a` after this function completes is undefined.</span>
<span class="sd">    interpolation : {&#39;linear&#39;, &#39;lower&#39;, &#39;higher&#39;, &#39;midpoint&#39;, &#39;nearest&#39;}</span>
<span class="sd">        This optional parameter specifies the interpolation method to</span>
<span class="sd">        use when the desired quantile lies between two data points</span>
<span class="sd">        ``i &lt; j``:</span>

<span class="sd">            * linear: ``i + (j - i) * fraction``, where ``fraction``</span>
<span class="sd">              is the fractional part of the index surrounded by ``i``</span>
<span class="sd">              and ``j``.</span>
<span class="sd">            * lower: ``i``.</span>
<span class="sd">            * higher: ``j``.</span>
<span class="sd">            * nearest: ``i`` or ``j``, whichever is nearest.</span>
<span class="sd">            * midpoint: ``(i + j) / 2``.</span>
<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left in</span>
<span class="sd">        the result as dimensions with size one. With this option, the</span>
<span class="sd">        result will broadcast correctly against the original array `a`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    quantile : BlockArray</span>
<span class="sd">        If `q` is a single quantile and `axis=None`, then the result</span>
<span class="sd">        is a scalar. If multiple quantiles are given, first axis of</span>
<span class="sd">        the result corresponds to the quantiles. The other axes are</span>
<span class="sd">        the axes that remain after the reduction of `a`. If the input</span>
<span class="sd">        contains integers or floats smaller than ``float``, the output</span>
<span class="sd">        data-type is ``float``. Otherwise, the output data-type is the</span>
<span class="sd">        same as that of the input. If `out` is specified, that array is</span>
<span class="sd">        returned instead.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    mean</span>
<span class="sd">    percentile : equivalent to quantile, but with q in the range [0, 100].</span>
<span class="sd">    median : equivalent to ``quantile(..., 0.5)``</span>
<span class="sd">    nanquantile</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Given a vector ``V`` of length ``N``, the q-th quantile of</span>
<span class="sd">    ``V`` is the value ``q`` of the way from the minimum to the</span>
<span class="sd">    maximum in a sorted copy of ``V``. The values and distances of</span>
<span class="sd">    the two nearest neighbors as well as the `interpolation` parameter</span>
<span class="sd">    will determine the quantile if the normalized ranking does not</span>
<span class="sd">    match the location of ``q`` exactly. This function is the same as</span>
<span class="sd">    the median if ``q=0.5``, the same as the minimum if ``q=0.0`` and the</span>
<span class="sd">    same as the maximum if ``q=1.0``.</span>

<span class="sd">    &#39;axis&#39; is currently not supported.</span>

<span class="sd">    &#39;out&#39; is currently not supported.</span>

<span class="sd">    &#39;overwrite_input&#39; is currently not supported.</span>

<span class="sd">    only &#39;linear&#39; &#39;interpolation&#39; is currently supported.</span>

<span class="sd">    &#39;keepdims&#39; is currently not supported.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; a = nps.array([[10, 7, 4], [3, 2, 1]])  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; a.get()  # doctest: +SKIP</span>
<span class="sd">    array([[10,  7,  4],</span>
<span class="sd">           [ 3,  2,  1]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;&#39;axis&#39; is currently not supported.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;&#39;out&#39; is currently not supported.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">overwrite_input</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;&#39;overwrite_input&#39; is currently not supported.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">interpolation</span> <span class="o">!=</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;only &#39;linear&#39; &#39;interpolation&#39; is currently supported.&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">keepdims</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;&#39;keepdims&#39; is currently not supported.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">interpolation</span><span class="p">)</span></div>


<div class="viewcode-block" id="std"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.std.html#nums.numpy.api.stats.std">[docs]</a><span class="k">def</span> <span class="nf">std</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the standard deviation along the specified axis.</span>

<span class="sd">    This docstring was copied from numpy.std.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Returns the standard deviation, a measure of the spread of a distribution,</span>
<span class="sd">    of the array elements. The standard deviation is computed for the</span>
<span class="sd">    flattened array by default, otherwise over the specified axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : BlockArray</span>
<span class="sd">        Calculate the standard deviation of these values.</span>
<span class="sd">    axis : None or int or tuple of ints, optional</span>
<span class="sd">        Axis or axes along which the standard deviation is computed. The</span>
<span class="sd">        default is to compute the standard deviation of the flattened array.</span>
<span class="sd">        If this is a tuple of ints, a standard deviation is performed over</span>
<span class="sd">        multiple axes, instead of a single axis or all the axes as before.</span>
<span class="sd">    dtype : dtype, optional</span>
<span class="sd">        Type to use in computing the standard deviation. For arrays of</span>
<span class="sd">        integer type the default is None.</span>
<span class="sd">    out : BlockArray, optional</span>
<span class="sd">        Alternative output array in which to place the result. It must have</span>
<span class="sd">        the same shape as the expected output but the type (of the calculated</span>
<span class="sd">        values) will be cast if necessary.</span>
<span class="sd">    ddof : int, optional</span>
<span class="sd">        Means Delta Degrees of Freedom.  The divisor used in calculations</span>
<span class="sd">        is ``N - ddof``, where ``N`` represents the number of elements.</span>
<span class="sd">        By default `ddof` is zero.</span>
<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left</span>
<span class="sd">        in the result as dimensions with size one. With this option,</span>
<span class="sd">        the result will broadcast correctly against the input array.</span>
<span class="sd">        If the default value is passed, then `keepdims` will not be</span>
<span class="sd">        passed through to the `std` method of sub-classes of</span>
<span class="sd">        `BlockArray`, however any non-default value will be.  If the</span>
<span class="sd">        sub-class&#39; method does not implement `keepdims` any</span>
<span class="sd">        exceptions will be raised.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    standard_deviation : BlockArray, see dtype parameter above.</span>
<span class="sd">        If `out` is None, return a new array containing the standard deviation,</span>
<span class="sd">        otherwise return a reference to the output array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    var, mean, nanmean, nanstd, nanvar</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The standard deviation is the square root of the average of the squared</span>
<span class="sd">    deviations from the mean, i.e., ``std = sqrt(mean(abs(x - x.mean())**2))``.</span>

<span class="sd">    The average squared deviation is normally calculated as</span>
<span class="sd">    ``x.sum() / N``, where ``N = len(x)``.  If, however, `ddof` is specified,</span>
<span class="sd">    the divisor ``N - ddof`` is used instead. In standard statistical</span>
<span class="sd">    practice, ``ddof=1`` provides an unbiased estimator of the variance</span>
<span class="sd">    of the infinite population. ``ddof=0`` provides a maximum likelihood</span>
<span class="sd">    estimate of the variance for normally distributed variables. The</span>
<span class="sd">    standard deviation computed in this function is the square root of</span>
<span class="sd">    the estimated variance, so even with ``ddof=1``, it will not be an</span>
<span class="sd">    unbiased estimate of the standard deviation per se.</span>

<span class="sd">    Note that, for complex numbers, `std` takes the absolute</span>
<span class="sd">    value before squaring, so that the result is always real and nonnegative.</span>

<span class="sd">    &#39;out&#39; is currently not supported.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; a = nps.array([[1, 2], [3, 4]])  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; nps.std(a).get()  # doctest: +SKIP</span>
<span class="sd">    array(1.1180339887498949) # may vary</span>
<span class="sd">    &gt;&gt;&gt; nps.std(a, axis=0).get()  # doctest: +SKIP</span>
<span class="sd">    array([1.,  1.])</span>
<span class="sd">    &gt;&gt;&gt; nps.std(a, axis=1).get()  # doctest: +SKIP</span>
<span class="sd">    array([0.5,  0.5])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;&#39;out&#39; is currently not supported.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span></div>


<div class="viewcode-block" id="var"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.var.html#nums.numpy.api.stats.var">[docs]</a><span class="k">def</span> <span class="nf">var</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the variance along the specified axis.</span>

<span class="sd">    This docstring was copied from numpy.var.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Returns the variance of the array elements, a measure of the spread of a</span>
<span class="sd">    distribution.  The variance is computed for the flattened array by</span>
<span class="sd">    default, otherwise over the specified axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : BlockArray</span>
<span class="sd">        Array containing numbers whose variance is desired.  If `a` is not an</span>
<span class="sd">        array, a conversion is attempted.</span>
<span class="sd">    axis : None or int or tuple of ints, optional</span>
<span class="sd">        Axis or axes along which the variance is computed.  The default is to</span>
<span class="sd">        compute the variance of the flattened array.</span>
<span class="sd">        If this is a tuple of ints, a variance is performed over multiple axes,</span>
<span class="sd">        instead of a single axis or all the axes as before.</span>
<span class="sd">    dtype : data-type, optional</span>
<span class="sd">        Type to use in computing the variance.  For arrays of integer type</span>
<span class="sd">        the default is `float`; for arrays of float types it is the same as</span>
<span class="sd">        the array type.</span>
<span class="sd">    out : BlockArray, optional</span>
<span class="sd">        Alternate output array in which to place the result.  It must have</span>
<span class="sd">        the same shape as the expected output, but the type is cast if</span>
<span class="sd">        necessary.</span>
<span class="sd">    ddof : int, optional</span>
<span class="sd">        &quot;Delta Degrees of Freedom&quot;: the divisor used in the calculation is</span>
<span class="sd">        ``N - ddof``, where ``N`` represents the number of elements. By</span>
<span class="sd">        default `ddof` is zero.</span>
<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left</span>
<span class="sd">        in the result as dimensions with size one. With this option,</span>
<span class="sd">        the result will broadcast correctly against the input array.</span>

<span class="sd">        If the default value is passed, then `keepdims` will not be</span>
<span class="sd">        passed through to the `var` method of sub-classes of</span>
<span class="sd">        `BlockArray`, however any non-default value will be.  If the</span>
<span class="sd">        sub-class&#39; method does not implement `keepdims` any</span>
<span class="sd">        exceptions will be raised.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    variance : BlockArray, see dtype parameter above</span>
<span class="sd">        If ``out=None``, returns a new array containing the variance;</span>
<span class="sd">        otherwise, a reference to the output array is returned.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    std, mean, nanmean, nanstd, nanvar</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The variance is the average of the squared deviations from the mean,</span>
<span class="sd">    i.e.,  ``var = mean(abs(x - x.mean())**2)``.</span>

<span class="sd">    The mean is normally calculated as ``x.sum() / N``, where ``N = len(x)``.</span>
<span class="sd">    If, however, `ddof` is specified, the divisor ``N - ddof`` is used</span>
<span class="sd">    instead.  In standard statistical practice, ``ddof=1`` provides an</span>
<span class="sd">    unbiased estimator of the variance of a hypothetical infinite population.</span>
<span class="sd">    ``ddof=0`` provides a maximum likelihood estimate of the variance for</span>
<span class="sd">    normally distributed variables.</span>

<span class="sd">    Note that for complex numbers, the absolute value is taken before</span>
<span class="sd">    squaring, so that the result is always real and nonnegative.</span>

<span class="sd">    &#39;out&#39; is currently not supported.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; a = nps.array([[1, 2], [3, 4]]) # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; nps.var(a).get()  # doctest: +SKIP</span>
<span class="sd">    array(1.25)</span>
<span class="sd">    &gt;&gt;&gt; nps.var(a, axis=0).get()  # doctest: +SKIP</span>
<span class="sd">    array([1.,  1.])</span>
<span class="sd">    &gt;&gt;&gt; nps.var(a, axis=1).get()  # doctest: +SKIP</span>
<span class="sd">    array([0.25,  0.25])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;&#39;out&#39; is currently not supported.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span></div>
</pre></div>

              </div>
              
              
              <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
              
          </main>
          

      </div>
    </div>
  
    <script src="../../../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>
  <footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2022, The NumS Team.<br>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.5.4.<br>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>