
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>nums.numpy.api.generated &#8212; NumS  documentation</title>
    
    <link href="../../../../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../../../../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
  
    
    <link rel="stylesheet"
      href="../../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
    <link rel="preload" as="font" type="font/woff2" crossorigin
      href="../../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
    <link rel="preload" as="font" type="font/woff2" crossorigin
      href="../../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">
  
    
      
  
    
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/styles/pydata-sphinx-theme.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/css/nums.css" />
    
    <link rel="preload" as="script" href="../../../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">
  
    <script id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    
      
      <link rel="icon" sizes="16x16" href="../../../../_static/icon.svg">
      
    
      
      <link rel="icon" sizes="32x32" href="../../../../_static/icon.svg">
      
    
      
      <link rel="apple-touch-icon" sizes="180x180" href="../../../../_static/apple-touch-icon-180x180.png">
      
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    

<a class="navbar-brand" href="../../../../index.html">
  <img src="../../../../_static/logo.svg" class="logo" alt="logo">
</a>


    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../get_started/index.html">
  Get Started
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../user_guide/index.html">
  User Guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../reference/index.html">
  API Reference
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../development/index.html">
  Development
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/nums-project/nums" rel="noopener" target="_blank" title="GitHub"><span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://twitter.com/nums_project" rel="noopener" target="_blank" title="Twitter"><span><i class="fab fa-twitter-square"></i></span>
            <label class="sr-only">Twitter</label></a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar">
              <div class="sidebar-start-items"><form class="bd-search d-flex align-items-center" action="../../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
              </div>
              <div class="sidebar-end-items">
              </div>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <h1>Source code for nums.numpy.api.generated</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (C) 2020 NumS Development Team.</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>

<span class="c1"># pylint: disable = redefined-builtin, too-many-lines, anomalous-backslash-in-string, unused-wildcard-import, wildcard-import</span>

<span class="kn">from</span> <span class="nn">nums.core.application_manager</span> <span class="kn">import</span> <span class="n">instance</span> <span class="k">as</span> <span class="n">_instance</span>
<span class="kn">from</span> <span class="nn">nums.core.array.blockarray</span> <span class="kn">import</span> <span class="n">BlockArray</span>
<span class="kn">from</span> <span class="nn">nums.numpy</span> <span class="kn">import</span> <span class="n">numpy_utils</span>

<span class="c1">############################################</span>
<span class="c1"># Generated Ops (Unary, Binary)</span>
<span class="c1">############################################</span>


<div class="viewcode-block" id="abs"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.abs.html#nums.numpy.abs">[docs]</a><span class="k">def</span> <span class="nf">abs</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Calculate the absolute value element-wise.</span>

<span class="sd">    ``nps.abs`` is a shorthand for this function.</span>

<span class="sd">    This docstring was copied from numpy.abs.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">        Input array.</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    absolute : BlockArray</span>
<span class="sd">        A BlockArray containing the absolute value of</span>
<span class="sd">        each element in `x`.  For complex input, ``a + ib``, the</span>
<span class="sd">        absolute value is :math:`\sqrt{ a^2 + b^2 }`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; x = nps.array([-1.2, 1.2])  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; nps.absolute(x).get()  # doctest: +SKIP</span>
<span class="sd">    array([ 1.2,  1.2])</span>
<span class="sd">    &gt;&gt;&gt; nps.absolute(nps.array([1.2 + 1j])).get()  # doctest: +SKIP</span>
<span class="sd">    array([1.56204994])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;abs&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="absolute"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.absolute.html#nums.numpy.absolute">[docs]</a><span class="k">def</span> <span class="nf">absolute</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Calculate the absolute value element-wise.</span>

<span class="sd">    ``nps.abs`` is a shorthand for this function.</span>

<span class="sd">    This docstring was copied from numpy.absolute.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">        Input array.</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    absolute : BlockArray</span>
<span class="sd">        A BlockArray containing the absolute value of</span>
<span class="sd">        each element in `x`.  For complex input, ``a + ib``, the</span>
<span class="sd">        absolute value is :math:`\sqrt{ a^2 + b^2 }`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; x = nps.array([-1.2, 1.2])  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; nps.absolute(x).get()  # doctest: +SKIP</span>
<span class="sd">    array([ 1.2,  1.2])</span>
<span class="sd">    &gt;&gt;&gt; nps.absolute(nps.array(1.2 + 1j)).get()  # doctest: +SKIP</span>
<span class="sd">    array(1.56204994)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;absolute&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="arccos"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.arccos.html#nums.numpy.arccos">[docs]</a><span class="k">def</span> <span class="nf">arccos</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Trigonometric inverse cosine, element-wise.</span>

<span class="sd">    The inverse of `cos` so that, if ``y = cos(x)``, then ``x = arccos(y)``.</span>

<span class="sd">    This docstring was copied from numpy.arccos.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">        `x`-coordinate on the unit circle.</span>
<span class="sd">        For real arguments, the domain is [-1, 1].</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    angle : BlockArray</span>
<span class="sd">        The angle of the ray intersecting the unit circle at the given</span>
<span class="sd">        `x`-coordinate in radians [0, pi].</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    cos, arctan, arcsin, emath.arccos</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    `arccos` is a multivalued function: for each `x` there are infinitely</span>
<span class="sd">    many numbers `z` such that `cos(z) = x`. The convention is to return</span>
<span class="sd">    the angle `z` whose real part lies in `[0, pi]`.</span>

<span class="sd">    For real-valued input data types, `arccos` always returns real output.</span>
<span class="sd">    For each value that cannot be expressed as a real number or infinity,</span>
<span class="sd">    it yields ``nan`` and sets the `invalid` floating point error flag.</span>

<span class="sd">    For complex-valued input, `arccos` is a complex analytic function that</span>
<span class="sd">    has branch cuts `[-inf, -1]` and `[1, inf]` and is continuous from</span>
<span class="sd">    above on the former and from below on the latter.</span>

<span class="sd">    The inverse `cos` is also known as `acos` or cos^-1.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    M. Abramowitz and I.A. Stegun, &quot;Handbook of Mathematical Functions&quot;,</span>
<span class="sd">    10th printing, 1964, pp. 79. http://www.math.sfu.ca/~cbm/aands/</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    We expect the arccos of 1 to be 0, and of -1 to be pi:</span>

<span class="sd">    &gt;&gt;&gt; nps.arccos(nps.array([1, -1])).get()  # doctest: +SKIP</span>
<span class="sd">    array([ 0.        ,  3.14159265])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;arccos&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="arccosh"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.arccosh.html#nums.numpy.arccosh">[docs]</a><span class="k">def</span> <span class="nf">arccosh</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Inverse hyperbolic cosine, element-wise.</span>

<span class="sd">    This docstring was copied from numpy.arccosh.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">        Input array.</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    arccosh : BlockArray</span>
<span class="sd">        Array of the same shape as `x`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>

<span class="sd">    cosh, arcsinh, sinh, arctanh, tanh</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    `arccosh` is a multivalued function: for each `x` there are infinitely</span>
<span class="sd">    many numbers `z` such that `cosh(z) = x`. The convention is to return the</span>
<span class="sd">    `z` whose imaginary part lies in `[-pi, pi]` and the real part in</span>
<span class="sd">    ``[0, inf]``.</span>

<span class="sd">    For real-valued input data types, `arccosh` always returns real output.</span>
<span class="sd">    For each value that cannot be expressed as a real number or infinity, it</span>
<span class="sd">    yields ``nan`` and sets the `invalid` floating point error flag.</span>

<span class="sd">    For complex-valued input, `arccosh` is a complex analytical function that</span>
<span class="sd">    has a branch cut `[-inf, 1]` and is continuous from above on it.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] M. Abramowitz and I.A. Stegun, &quot;Handbook of Mathematical Functions&quot;,</span>
<span class="sd">           10th printing, 1964, pp. 86. http://www.math.sfu.ca/~cbm/aands/</span>
<span class="sd">    .. [2] Wikipedia, &quot;Inverse hyperbolic function&quot;,</span>
<span class="sd">           https://en.wikipedia.org/wiki/Arccosh</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.arccosh(nps.array([nps.e, 10.0])).get()  # doctest: +SKIP</span>
<span class="sd">    array([ 1.65745445,  2.99322285])</span>
<span class="sd">    &gt;&gt;&gt; nps.arccosh(nps.array(1)).get()  # doctest: +SKIP</span>
<span class="sd">    array(0.0)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;arccosh&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="arcsin"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.arcsin.html#nums.numpy.arcsin">[docs]</a><span class="k">def</span> <span class="nf">arcsin</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Inverse sine, element-wise.</span>

<span class="sd">    This docstring was copied from numpy.arcsin.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">        `y`-coordinate on the unit circle.</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    angle : BlockArray</span>
<span class="sd">        The inverse sine of each element in `x`, in radians and in the</span>
<span class="sd">        closed interval ``[-pi/2, pi/2]``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    sin, cos, arccos, tan, arctan, arctan2, emath.arcsin</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    `arcsin` is a multivalued function: for each `x` there are infinitely</span>
<span class="sd">    many numbers `z` such that :math:`sin(z) = x`.  The convention is to</span>
<span class="sd">    return the angle `z` whose real part lies in [-pi/2, pi/2].</span>

<span class="sd">    For real-valued input data types, *arcsin* always returns real output.</span>
<span class="sd">    For each value that cannot be expressed as a real number or infinity,</span>
<span class="sd">    it yields ``nan`` and sets the `invalid` floating point error flag.</span>

<span class="sd">    For complex-valued input, `arcsin` is a complex analytic function that</span>
<span class="sd">    has, by convention, the branch cuts [-inf, -1] and [1, inf]  and is</span>
<span class="sd">    continuous from above on the former and from below on the latter.</span>

<span class="sd">    The inverse sine is also known as `asin` or sin^{-1}.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    Abramowitz, M. and Stegun, I. A., *Handbook of Mathematical Functions*,</span>
<span class="sd">    10th printing, New York: Dover, 1964, pp. 79ff.</span>
<span class="sd">    http://www.math.sfu.ca/~cbm/aands/</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.arcsin(nps.array(1)).get()     # pi/2  # doctest: +SKIP</span>
<span class="sd">    array(1.57079633)</span>
<span class="sd">    &gt;&gt;&gt; nps.arcsin(nps.array(-1)).get()    # -pi/2  # doctest: +SKIP</span>
<span class="sd">    array(-1.57079633)</span>
<span class="sd">    &gt;&gt;&gt; nps.arcsin(nps.array(0)).get()  # doctest: +SKIP</span>
<span class="sd">    array(0.)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;arcsin&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="arcsinh"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.arcsinh.html#nums.numpy.arcsinh">[docs]</a><span class="k">def</span> <span class="nf">arcsinh</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Inverse hyperbolic sine element-wise.</span>

<span class="sd">    This docstring was copied from numpy.arcsinh.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">        Input array.</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : BlockArray or scalar</span>
<span class="sd">        Array of the same shape as `x`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    `arcsinh` is a multivalued function: for each `x` there are infinitely</span>
<span class="sd">    many numbers `z` such that `sinh(z) = x`. The convention is to return the</span>
<span class="sd">    `z` whose imaginary part lies in `[-pi/2, pi/2]`.</span>

<span class="sd">    For real-valued input data types, `arcsinh` always returns real output.</span>
<span class="sd">    For each value that cannot be expressed as a real number or infinity, it</span>
<span class="sd">    returns ``nan`` and sets the `invalid` floating point error flag.</span>

<span class="sd">    For complex-valued input, `arccos` is a complex analytical function that</span>
<span class="sd">    has branch cuts `[1j, infj]` and `[-1j, -infj]` and is continuous from</span>
<span class="sd">    the right on the former and from the left on the latter.</span>

<span class="sd">    The inverse hyperbolic sine is also known as `asinh` or ``sinh^-1``.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] M. Abramowitz and I.A. Stegun, &quot;Handbook of Mathematical Functions&quot;,</span>
<span class="sd">           10th printing, 1964, pp. 86. http://www.math.sfu.ca/~cbm/aands/</span>
<span class="sd">    .. [2] Wikipedia, &quot;Inverse hyperbolic function&quot;,</span>
<span class="sd">           https://en.wikipedia.org/wiki/Arcsinh</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.arcsinh(nps.array([nps.e, 10.0])).get()  # doctest: +SKIP</span>
<span class="sd">    array([ 1.72538256,  2.99822295])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;arcsinh&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="arctan"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.arctan.html#nums.numpy.arctan">[docs]</a><span class="k">def</span> <span class="nf">arctan</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Trigonometric inverse tangent, element-wise.</span>

<span class="sd">    The inverse of tan, so that if ``y = tan(x)`` then ``x = arctan(y)``.</span>

<span class="sd">    This docstring was copied from numpy.arctan.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : BlockArray or scalar</span>
<span class="sd">        Out has the same shape as `x`.  Its real part is in</span>
<span class="sd">        ``[-pi/2, pi/2]`` (``arctan(+/-inf)`` returns ``+/-pi/2``).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    arctan2 : The &quot;four quadrant&quot; arctan of the angle formed by (`x`, `y`)</span>
<span class="sd">        and the positive `x`-axis.</span>
<span class="sd">    angle : Argument of complex values.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    `arctan` is a multi-valued function: for each `x` there are infinitely</span>
<span class="sd">    many numbers `z` such that tan(`z`) = `x`.  The convention is to return</span>
<span class="sd">    the angle `z` whose real part lies in [-pi/2, pi/2].</span>

<span class="sd">    For real-valued input data types, `arctan` always returns real output.</span>
<span class="sd">    For each value that cannot be expressed as a real number or infinity,</span>
<span class="sd">    it yields ``nan`` and sets the `invalid` floating point error flag.</span>

<span class="sd">    For complex-valued input, `arctan` is a complex analytic function that</span>
<span class="sd">    has [`1j, infj`] and [`-1j, -infj`] as branch cuts, and is continuous</span>
<span class="sd">    from the left on the former and from the right on the latter.</span>

<span class="sd">    The inverse tangent is also known as `atan` or tan^{-1}.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    Abramowitz, M. and Stegun, I. A., *Handbook of Mathematical Functions*,</span>
<span class="sd">    10th printing, New York: Dover, 1964, pp. 79.</span>
<span class="sd">    http://www.math.sfu.ca/~cbm/aands/</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    We expect the arctan of 0 to be 0, and of 1 to be pi/4:</span>

<span class="sd">    &gt;&gt;&gt; nps.arctan(nps.array([0, 1])).get()  # doctest: +SKIP</span>
<span class="sd">    array([ 0.        ,  0.78539816])</span>

<span class="sd">    &gt;&gt;&gt; nps.pi/4  # doctest: +SKIP</span>
<span class="sd">    0.78539816339744828</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;arctan&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="arctanh"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.arctanh.html#nums.numpy.arctanh">[docs]</a><span class="k">def</span> <span class="nf">arctanh</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Inverse hyperbolic tangent element-wise.</span>

<span class="sd">    This docstring was copied from numpy.arctanh.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">        Input array.</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : BlockArray or scalar</span>
<span class="sd">        Array of the same shape as `x`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    `arctanh` is a multivalued function: for each `x` there are infinitely</span>
<span class="sd">    many numbers `z` such that `tanh(z) = x`. The convention is to return</span>
<span class="sd">    the `z` whose imaginary part lies in `[-pi/2, pi/2]`.</span>

<span class="sd">    For real-valued input data types, `arctanh` always returns real output.</span>
<span class="sd">    For each value that cannot be expressed as a real number or infinity,</span>
<span class="sd">    it yields ``nan`` and sets the `invalid` floating point error flag.</span>

<span class="sd">    For complex-valued input, `arctanh` is a complex analytical function</span>
<span class="sd">    that has branch cuts `[-1, -inf]` and `[1, inf]` and is continuous from</span>
<span class="sd">    above on the former and from below on the latter.</span>

<span class="sd">    The inverse hyperbolic tangent is also known as `atanh` or ``tanh^-1``.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] M. Abramowitz and I.A. Stegun, &quot;Handbook of Mathematical Functions&quot;,</span>
<span class="sd">           10th printing, 1964, pp. 86. http://www.math.sfu.ca/~cbm/aands/</span>
<span class="sd">    .. [2] Wikipedia, &quot;Inverse hyperbolic function&quot;,</span>
<span class="sd">           https://en.wikipedia.org/wiki/Arctanh</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.arctanh(nps.array([0, -0.5])).get()  # doctest: +SKIP</span>
<span class="sd">    array([ 0.        , -0.54930614])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;arctanh&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="bitwise_not"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.bitwise_not.html#nums.numpy.bitwise_not">[docs]</a><span class="k">def</span> <span class="nf">bitwise_not</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Compute bit-wise inversion, or bit-wise NOT, element-wise.</span>

<span class="sd">    This docstring was copied from numpy.bitwise_not.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Computes the bit-wise NOT of the underlying binary representation of</span>
<span class="sd">    the integers in the input arrays. This ufunc implements the C/Python</span>
<span class="sd">    operator ``~``.</span>

<span class="sd">    For signed integer inputs, the two&#39;s complement is returned.  In a</span>
<span class="sd">    two&#39;s-complement system negative numbers are represented by the two&#39;s</span>
<span class="sd">    complement of the absolute value. This is the most common method of</span>
<span class="sd">    representing signed integers on computers [1]_. A N-bit</span>
<span class="sd">    two&#39;s-complement system can represent every integer in the range</span>
<span class="sd">    :math:`-2^{N-1}` to :math:`+2^{N-1}-1`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">        Only integer and boolean types are handled.</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : BlockArray or scalar</span>
<span class="sd">        Result.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    bitwise_and, bitwise_or, bitwise_xor</span>
<span class="sd">    logical_not</span>
<span class="sd">    binary_repr :</span>
<span class="sd">        Return the binary representation of the input number as a string.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Wikipedia, &quot;Two&#39;s complement&quot;,</span>
<span class="sd">        https://en.wikipedia.org/wiki/Two&#39;s_complement</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    We&#39;ve seen that 13 is represented by ``00001101``.</span>
<span class="sd">    The invert or bit-wise NOT of 13 is then:</span>

<span class="sd">    &gt;&gt;&gt; x = nps.invert(nps.array(13, dtype=nps.uint8))  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; x.get()  # doctest: +SKIP</span>
<span class="sd">    array(242, dtype=uint8)</span>

<span class="sd">    The result depends on the bit-width:</span>

<span class="sd">    &gt;&gt;&gt; x = nps.invert(nps.array(13, dtype=nps.uint16)).get()  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; x  # doctest: +SKIP</span>
<span class="sd">    65522</span>
<span class="sd">    &gt;&gt;&gt; nps.binary_repr(x, width=16).get()  # doctest: +SKIP</span>
<span class="sd">    &#39;1111111111110010&#39;</span>

<span class="sd">    When using signed integer types the result is the two&#39;s complement of</span>
<span class="sd">    the result for the unsigned type:</span>

<span class="sd">    &gt;&gt;&gt; nps.invert(nps.array([13], dtype=nps.int8)).get()  # doctest: +SKIP</span>
<span class="sd">    array([-14], dtype=int8)</span>
<span class="sd">    &gt;&gt;&gt; nps.binary_repr(-14, width=8).get()  # doctest: +SKIP</span>
<span class="sd">    &#39;11110010&#39;</span>

<span class="sd">    Booleans are accepted as well:</span>

<span class="sd">    &gt;&gt;&gt; nps.invert(nps.array([True, False])).get()  # doctest: +SKIP</span>
<span class="sd">    array([False,  True])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;bitwise_not&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="cbrt"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.cbrt.html#nums.numpy.cbrt">[docs]</a><span class="k">def</span> <span class="nf">cbrt</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Return the cube-root of an array, element-wise.</span>

<span class="sd">    This docstring was copied from numpy.cbrt.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">        The values whose cube-roots are required.</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray</span>
<span class="sd">        An array of the same shape as `x`, containing the cube</span>
<span class="sd">        cube-root of each element in `x`.</span>
<span class="sd">        If `out` was provided, `y` is a reference to it.</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.cbrt(nps.array([1,8,27])).get()  # doctest: +SKIP</span>
<span class="sd">    array([ 1.,  2.,  3.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;cbrt&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="ceil"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.ceil.html#nums.numpy.ceil">[docs]</a><span class="k">def</span> <span class="nf">ceil</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Return the ceiling of the input, element-wise.</span>

<span class="sd">    This docstring was copied from numpy.ceil.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    The ceil of the scalar `x` is the smallest integer `i`, such that</span>
<span class="sd">    `i &gt;= x`.  It is often denoted as :math:`\lceil x \rceil`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">        Input data.</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray or scalar</span>
<span class="sd">        The ceiling of each element in `x`, with `float` dtype.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    floor, trunc, rint</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; a = nps.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; nps.ceil(a).get()  # doctest: +SKIP</span>
<span class="sd">    array([-1., -1., -0.,  1.,  2.,  2.,  2.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;ceil&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="conj"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.conj.html#nums.numpy.conj">[docs]</a><span class="k">def</span> <span class="nf">conj</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Return the complex conjugate, element-wise.</span>

<span class="sd">    This docstring was copied from numpy.conj.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    The complex conjugate of a complex number is obtained by changing the</span>
<span class="sd">    sign of its imaginary part.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">        Input value.</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray</span>
<span class="sd">        The complex conjugate of `x`, with same dtype as `y`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.conjugate(nps.array(1+2j)).get()  # doctest: +SKIP</span>
<span class="sd">    array(1.-2.j)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;conj&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="conjugate"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.conjugate.html#nums.numpy.conjugate">[docs]</a><span class="k">def</span> <span class="nf">conjugate</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Return the complex conjugate, element-wise.</span>

<span class="sd">    This docstring was copied from numpy.conjugate.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    The complex conjugate of a complex number is obtained by changing the</span>
<span class="sd">    sign of its imaginary part.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">        Input value.</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray</span>
<span class="sd">        The complex conjugate of `x`, with same dtype as `y`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.conjugate(nps.array(1+2j)).get()  # doctest: +SKIP</span>
<span class="sd">    array(1.-2.j)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;conjugate&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="cos"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.cos.html#nums.numpy.cos">[docs]</a><span class="k">def</span> <span class="nf">cos</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Cosine element-wise.</span>

<span class="sd">    This docstring was copied from numpy.cos.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">        Input array in radians.</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray</span>
<span class="sd">        The corresponding cosine values.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If `out` is provided, the function writes the result into it,</span>
<span class="sd">    and returns a reference to `out`.  (See Examples)</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.</span>
<span class="sd">    New York, NY: Dover, 1972.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.cos(nps.array([0, nps.pi/2, nps.pi])).get()  # doctest: +SKIP</span>
<span class="sd">    array([  1.00000000e+00,   6.12303177e-17,  -1.00000000e+00])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;cos&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="cosh"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.cosh.html#nums.numpy.cosh">[docs]</a><span class="k">def</span> <span class="nf">cosh</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Hyperbolic cosine, element-wise.</span>

<span class="sd">    This docstring was copied from numpy.cosh.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Equivalent to ``1/2 * (nps.exp(x) + nps.exp(-x))`` and ``nps.cos(1j*x).get()``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">        Input array.</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : BlockArray or scalar</span>
<span class="sd">        Output array of same shape as `x`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.cosh(nps.array(0)).get()  # doctest: +SKIP</span>
<span class="sd">    array(1.)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;cosh&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="deg2rad"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.deg2rad.html#nums.numpy.deg2rad">[docs]</a><span class="k">def</span> <span class="nf">deg2rad</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Convert angles from degrees to radians.</span>

<span class="sd">    This docstring was copied from numpy.deg2rad.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">        Angles in degrees.</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray</span>
<span class="sd">        The corresponding angle in radians.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    rad2deg : Convert angles from radians to degrees.</span>
<span class="sd">    unwrap : Remove large jumps in angle by wrapping.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    ``deg2rad(x)`` is ``x * pi / 180``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.deg2rad(nps.array(180)).get()  # doctest: +SKIP</span>
<span class="sd">    array(3.14159265)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;deg2rad&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="degrees"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.degrees.html#nums.numpy.degrees">[docs]</a><span class="k">def</span> <span class="nf">degrees</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Convert angles from radians to degrees.</span>

<span class="sd">    This docstring was copied from numpy.degrees.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">        Input array in radians.</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray of floats</span>
<span class="sd">        The corresponding degree values; if `out` was supplied this is a</span>
<span class="sd">        reference to it.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    rad2deg : equivalent function</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    Convert a radian array to degrees</span>

<span class="sd">    &gt;&gt;&gt; rad = nps.arange(12.) *nps.pi/6  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; nps.degrees(rad).get()  # doctest: +SKIP</span>
<span class="sd">    array([   0.,   30.,   60.,   90.,  120.,  150.,  180.,  210.,  240.,</span>
<span class="sd">            270.,  300.,  330.])</span>

<span class="sd">    &gt;&gt;&gt; out = nps.zeros((rad.shape))  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; r = nps.degrees(rad, out)  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; nps.all(r == out).get()  # doctest: +SKIP</span>
<span class="sd">    array(True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;degrees&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="exp"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.exp.html#nums.numpy.exp">[docs]</a><span class="k">def</span> <span class="nf">exp</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Calculate the exponential of all elements in the input array.</span>

<span class="sd">    This docstring was copied from numpy.exp.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">        Input values.</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : BlockArray or scalar</span>
<span class="sd">        Output array, element-wise exponential of `x`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    expm1 : Calculate ``exp(x) - 1`` for all elements in the array.</span>
<span class="sd">    exp2  : Calculate ``2**x`` for all elements in the array.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The irrational number ``e`` is also known as Euler&#39;s number.  It is</span>
<span class="sd">    approximately 2.718281, and is the base of the natural logarithm,</span>
<span class="sd">    ``ln`` (this means that, if :math:`x = \ln y = \log_e y`,</span>
<span class="sd">    then :math:`e^x = y`. For real input, ``exp(x)`` is always positive.</span>

<span class="sd">    For complex arguments, ``x = a + ib``, we can write</span>
<span class="sd">    :math:`e^x = e^a e^{ib}`.  The first term, :math:`e^a`, is already</span>
<span class="sd">    known (it is the real argument, described above).  The second term,</span>
<span class="sd">    :math:`e^{ib}`, is :math:`\cos b + i \sin b`, a function with</span>
<span class="sd">    magnitude 1 and a periodic phase.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Wikipedia, &quot;Exponential function&quot;,</span>
<span class="sd">           https://en.wikipedia.org/wiki/Exponential_function</span>
<span class="sd">    .. [2] M. Abramovitz and I. A. Stegun, &quot;Handbook of Mathematical Functions</span>
<span class="sd">           with Formulas, Graphs, and Mathematical Tables,&quot; Dover, 1964, p. 69,</span>
<span class="sd">           http://www.math.sfu.ca/~cbm/aands/page_69.htm</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;exp&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="exp2"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.exp2.html#nums.numpy.exp2">[docs]</a><span class="k">def</span> <span class="nf">exp2</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Calculate `2**p` for all `p` in the input array.</span>

<span class="sd">    This docstring was copied from numpy.exp2.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">        Input values.</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : BlockArray or scalar</span>
<span class="sd">        Element-wise 2 to the power `x`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    power</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.exp2(nps.array([2, 3])).get()  # doctest: +SKIP</span>
<span class="sd">    array([ 4.,  8.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;exp2&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="expm1"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.expm1.html#nums.numpy.expm1">[docs]</a><span class="k">def</span> <span class="nf">expm1</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Calculate ``exp(x) - 1`` for all elements in the array.</span>

<span class="sd">    This docstring was copied from numpy.expm1.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">        Input values.</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : BlockArray or scalar</span>
<span class="sd">        Element-wise exponential minus one: ``out = exp(x) - 1``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    log1p : ``log(1 + x)``, the inverse of expm1.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function provides greater precision than ``exp(x) - 1``</span>
<span class="sd">    for small values of ``x``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    The true value of ``exp(1e-10) - 1`` is ``1.00000000005e-10`` to</span>
<span class="sd">    about 32 significant digits. This example shows the superiority of</span>
<span class="sd">    expm1 in this case.</span>

<span class="sd">    &gt;&gt;&gt; nps.expm1(nps.array(1e-10)).get()  # doctest: +SKIP</span>
<span class="sd">    array(1.e-10)</span>
<span class="sd">    &gt;&gt;&gt; nps.exp(nps.array(1e-10)).get() - 1  # doctest: +SKIP</span>
<span class="sd">    1.000000082740371e-10</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;expm1&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="fabs"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.fabs.html#nums.numpy.fabs">[docs]</a><span class="k">def</span> <span class="nf">fabs</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Compute the absolute values element-wise.</span>

<span class="sd">    This docstring was copied from numpy.fabs.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    This function returns the absolute values (positive magnitude) of the</span>
<span class="sd">    data in `x`. Complex values are not handled, use `absolute` to find the</span>
<span class="sd">    absolute values of complex data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">        The array of numbers for which the absolute values are required. If</span>
<span class="sd">        `x` is a scalar, the result `y` will also be a scalar.</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray or scalar</span>
<span class="sd">        The absolute values of `x`, the returned values are always floats.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    absolute : Absolute values including `complex` types.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.fabs(nps.array(-1)).get()  # doctest: +SKIP</span>
<span class="sd">    array(1.)</span>
<span class="sd">    &gt;&gt;&gt; nps.fabs(nps.array([-1.2, 1.2])).get()  # doctest: +SKIP</span>
<span class="sd">    array([ 1.2,  1.2])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;fabs&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="floor"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.floor.html#nums.numpy.floor">[docs]</a><span class="k">def</span> <span class="nf">floor</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Return the floor of the input, element-wise.</span>

<span class="sd">    This docstring was copied from numpy.floor.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    The floor of the scalar `x` is the largest integer `i`, such that</span>
<span class="sd">    `i &lt;= x`.  It is often denoted as :math:`\lfloor x \rfloor`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">        Input data.</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray or scalar</span>
<span class="sd">        The floor of each element in `x`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ceil, trunc, rint</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Some spreadsheet programs calculate the &quot;floor-towards-zero&quot;, in other</span>
<span class="sd">    words ``floor(-2.5) == -2``.  NumPy instead uses the definition of</span>
<span class="sd">    `floor` where `floor(-2.5) == -3`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; a = nps.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; nps.floor(a).get()  # doctest: +SKIP</span>
<span class="sd">    array([-2., -2., -1.,  0.,  1.,  1.,  2.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;floor&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="invert"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.invert.html#nums.numpy.invert">[docs]</a><span class="k">def</span> <span class="nf">invert</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Compute bit-wise inversion, or bit-wise NOT, element-wise.</span>

<span class="sd">    This docstring was copied from numpy.invert.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Computes the bit-wise NOT of the underlying binary representation of</span>
<span class="sd">    the integers in the input arrays. This ufunc implements the C/Python</span>
<span class="sd">    operator ``~``.</span>

<span class="sd">    For signed integer inputs, the two&#39;s complement is returned.  In a</span>
<span class="sd">    two&#39;s-complement system negative numbers are represented by the two&#39;s</span>
<span class="sd">    complement of the absolute value. This is the most common method of</span>
<span class="sd">    representing signed integers on computers [1]_. A N-bit</span>
<span class="sd">    two&#39;s-complement system can represent every integer in the range</span>
<span class="sd">    :math:`-2^{N-1}` to :math:`+2^{N-1}-1`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">        Only integer and boolean types are handled.</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : BlockArray or scalar</span>
<span class="sd">        Result.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    bitwise_and, bitwise_or, bitwise_xor</span>
<span class="sd">    logical_not</span>
<span class="sd">    binary_repr :</span>
<span class="sd">        Return the binary representation of the input number as a string.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Wikipedia, &quot;Two&#39;s complement&quot;,</span>
<span class="sd">        https://en.wikipedia.org/wiki/Two&#39;s_complement</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    We&#39;vThe doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    e seen that 13 is represented by ``00001101``.</span>
<span class="sd">    The invert or bit-wise NOT of 13 is then:</span>

<span class="sd">    &gt;&gt;&gt; x = nps.invert(nps.array(13, dtype=nps.uint8))  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; x.get()  # doctest: +SKIP</span>
<span class="sd">    array(242, dtype=uint8)</span>

<span class="sd">    When using signed integer types the result is the two&#39;s complement of</span>
<span class="sd">    the result for the unsigned type:</span>

<span class="sd">    &gt;&gt;&gt; nps.invert(nps.array([13], dtype=nps.int8)).get()  # doctest: +SKIP</span>
<span class="sd">    array([-14], dtype=int8)</span>

<span class="sd">    Booleans are accepted as well:</span>

<span class="sd">    &gt;&gt;&gt; nps.invert(nps.array([True, False])).get()  # doctest: +SKIP</span>
<span class="sd">    array([False,  True])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;invert&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="isfinite"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.isfinite.html#nums.numpy.isfinite">[docs]</a><span class="k">def</span> <span class="nf">isfinite</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Test element-wise for finiteness (not infinity or not Not a Number).</span>

<span class="sd">    This docstring was copied from numpy.isfinite.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    The result is returned as a boolean array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">        Input values.</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray, bool</span>
<span class="sd">        True where ``x`` is not positive infinity, negative infinity,</span>
<span class="sd">        or NaN; false otherwise.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    isinf, isneginf, isposinf, isnan</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Not a Number, positive infinity and negative infinity are considered</span>
<span class="sd">    to be non-finite.</span>

<span class="sd">    NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic</span>
<span class="sd">    (IEEE 754). This means that Not a Number is not equivalent to infinity.</span>
<span class="sd">    Also that positive infinity is not equivalent to negative infinity. But</span>
<span class="sd">    infinity is equivalent to positive infinity.  Errors result if the</span>
<span class="sd">    second argument is also supplied when `x` is a scalar input, or if</span>
<span class="sd">    first and second arguments have different shapes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.isfinite(nps.array(1)).get()  # doctest: +SKIP</span>
<span class="sd">    array(True)</span>
<span class="sd">    &gt;&gt;&gt; nps.isfinite(nps.array(0)).get()  # doctest: +SKIP</span>
<span class="sd">    array(True)</span>
<span class="sd">    &gt;&gt;&gt; nps.isfinite(nps.array(nps.nan)).get()  # doctest: +SKIP</span>
<span class="sd">    array(False)</span>
<span class="sd">    &gt;&gt;&gt; nps.isfinite(nps.array(nps.inf)).get()  # doctest: +SKIP</span>
<span class="sd">    array(False)</span>
<span class="sd">    &gt;&gt;&gt; nps.isfinite(nps.array(nps.NINF)).get()  # doctest: +SKIP</span>
<span class="sd">    array(False)</span>

<span class="sd">    &gt;&gt;&gt; x = nps.array([-nps.inf, 0., nps.inf])  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; y = nps.array([2, 2, 2])  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; nps.isfinite(x, y).get()  # doctest: +SKIP</span>
<span class="sd">    array([0, 1, 0])</span>
<span class="sd">    &gt;&gt;&gt; y.get()  # doctest: +SKIP</span>
<span class="sd">    array([0, 1, 0])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;isfinite&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="isinf"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.isinf.html#nums.numpy.isinf">[docs]</a><span class="k">def</span> <span class="nf">isinf</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Test element-wise for positive or negative infinity.</span>

<span class="sd">    This docstring was copied from numpy.isinf.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Returns a boolean array of the same shape as `x`, True where ``x ==</span>
<span class="sd">    +/-inf``, otherwise False.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">        Input values</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : boolean BlockArray</span>
<span class="sd">        True where ``x`` is positive or negative infinity, false otherwise.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    isneginf, isposinf, isnan, isfinite</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic</span>
<span class="sd">    (IEEE 754).</span>

<span class="sd">    Errors result if the second argument is supplied when the first</span>
<span class="sd">    argument is a scalar, or if the first and second arguments have</span>
<span class="sd">    different shapes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.isinf(nps.array(nps.inf)).get()  # doctest: +SKIP</span>
<span class="sd">    array(True)</span>
<span class="sd">    &gt;&gt;&gt; nps.isinf(nps.array(nps.nan)).get()  # doctest: +SKIP</span>
<span class="sd">    array(False)</span>
<span class="sd">    &gt;&gt;&gt; nps.isinf(nps.array(nps.NINF)).get()  # doctest: +SKIP</span>
<span class="sd">    array(True)</span>
<span class="sd">    &gt;&gt;&gt; nps.isinf(nps.array([nps.inf, -nps.inf, 1.0, nps.nan])).get()  # doctest: +SKIP</span>
<span class="sd">    array([ True,  True, False, False])</span>

<span class="sd">    &gt;&gt;&gt; x = nps.array([-nps.inf, 0., nps.inf])  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; y = nps.array([2, 2, 2])  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; nps.isinf(x, y).get()  # doctest: +SKIP</span>
<span class="sd">    array([1, 0, 1])</span>
<span class="sd">    &gt;&gt;&gt; y.get()  # doctest: +SKIP</span>
<span class="sd">    array([1, 0, 1])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;isinf&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="isnan"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.isnan.html#nums.numpy.isnan">[docs]</a><span class="k">def</span> <span class="nf">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Test element-wise for NaN and return result as a boolean array.</span>

<span class="sd">    This docstring was copied from numpy.isnan.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">        Input array.</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray or bool</span>
<span class="sd">        True where ``x`` is NaN, false otherwise.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    isinf, isneginf, isposinf, isfinite, isnat</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic</span>
<span class="sd">    (IEEE 754). This means that Not a Number is not equivalent to infinity.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.  # doctest: +SKIP</span>

<span class="sd">    &gt;&gt;&gt; nps.isnan(nps.array(nps.nan)).get()</span>
<span class="sd">    array(True)</span>
<span class="sd">    &gt;&gt;&gt; nps.isnan(nps.array(nps.inf)).get()  # doctest: +SKIP</span>
<span class="sd">    array(False)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;isnan&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="log"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.log.html#nums.numpy.log">[docs]</a><span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Natural logarithm, element-wise.</span>

<span class="sd">    This docstring was copied from numpy.log.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    The natural logarithm `log` is the inverse of the exponential function,</span>
<span class="sd">    so that `log(exp(x)) = x`. The natural logarithm is logarithm in base</span>
<span class="sd">    `e`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">        Input value.</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray</span>
<span class="sd">        The natural logarithm of `x`, element-wise.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    log10, log2, log1p</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Logarithm is a multivalued function: for each `x` there is an infinite</span>
<span class="sd">    number of `z` such that `exp(z) = x`. The convention is to return the</span>
<span class="sd">    `z` whose imaginary part lies in `[-pi, pi]`.</span>

<span class="sd">    For real-valued input data types, `log` always returns real output. For</span>
<span class="sd">    each value that cannot be expressed as a real number or infinity, it</span>
<span class="sd">    yields ``nan`` and sets the `invalid` floating point error flag.</span>

<span class="sd">    For complex-valued input, `log` is a complex analytical function that</span>
<span class="sd">    has a branch cut `[-inf, 0]` and is continuous from above on it. `log`</span>
<span class="sd">    handles the floating-point negative zero as an infinitesimal negative</span>
<span class="sd">    number, conforming to the C99 standard.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] M. Abramowitz and I.A. Stegun, &quot;Handbook of Mathematical Functions&quot;,</span>
<span class="sd">           10th printing, 1964, pp. 67. http://www.math.sfu.ca/~cbm/aands/</span>
<span class="sd">    .. [2] Wikipedia, &quot;Logarithm&quot;. https://en.wikipedia.org/wiki/Logarithm</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.log(nps.array([1, nps.e, nps.e**2, 0])).get()  # doctest: +SKIP</span>
<span class="sd">    array([  0.,   1.,   2., -Inf])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;log&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="log10"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.log10.html#nums.numpy.log10">[docs]</a><span class="k">def</span> <span class="nf">log10</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Return the base 10 logarithm of the input array, element-wise.</span>

<span class="sd">    This docstring was copied from numpy.log10.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">        Input values.</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray</span>
<span class="sd">        The logarithm to the base 10 of `x`, element-wise. NaNs are</span>
<span class="sd">        returned where x is negative.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Logarithm is a multivalued function: for each `x` there is an infinite</span>
<span class="sd">    number of `z` such that `10**z = x`. The convention is to return the</span>
<span class="sd">    `z` whose imaginary part lies in `[-pi, pi]`.</span>

<span class="sd">    For real-valued input data types, `log10` always returns real output.</span>
<span class="sd">    For each value that cannot be expressed as a real number or infinity,</span>
<span class="sd">    it yields ``nan`` and sets the `invalid` floating point error flag.</span>

<span class="sd">    For complex-valued input, `log10` is a complex analytical function that</span>
<span class="sd">    has a branch cut `[-inf, 0]` and is continuous from above on it.</span>
<span class="sd">    `log10` handles the floating-point negative zero as an infinitesimal</span>
<span class="sd">    negative number, conforming to the C99 standard.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] M. Abramowitz and I.A. Stegun, &quot;Handbook of Mathematical Functions&quot;,</span>
<span class="sd">           10th printing, 1964, pp. 67. http://www.math.sfu.ca/~cbm/aands/</span>
<span class="sd">    .. [2] Wikipedia, &quot;Logarithm&quot;. https://en.wikipedia.org/wiki/Logarithm</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.log10(nps.array([1e-15, -3.])).get()  # doctest: +SKIP</span>
<span class="sd">    array([-15.,  nan])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;log10&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="log1p"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.log1p.html#nums.numpy.log1p">[docs]</a><span class="k">def</span> <span class="nf">log1p</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Return the natural logarithm of one plus the input array, element-wise.</span>

<span class="sd">    This docstring was copied from numpy.log1p.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Calculates ``log(1 + x)``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">        Input values.</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray</span>
<span class="sd">        Natural logarithm of `1 + x`, element-wise.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    expm1 : ``exp(x) - 1``, the inverse of `log1p`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For real-valued input, `log1p` is accurate also for `x` so small</span>
<span class="sd">    that `1 + x == 1` in floating-point accuracy.</span>

<span class="sd">    Logarithm is a multivalued function: for each `x` there is an infinite</span>
<span class="sd">    number of `z` such that `exp(z) = 1 + x`. The convention is to return</span>
<span class="sd">    the `z` whose imaginary part lies in `[-pi, pi]`.</span>

<span class="sd">    For real-valued input data types, `log1p` always returns real output.</span>
<span class="sd">    For each value that cannot be expressed as a real number or infinity,</span>
<span class="sd">    it yields ``nan`` and sets the `invalid` floating point error flag.</span>

<span class="sd">    For complex-valued input, `log1p` is a complex analytical function that</span>
<span class="sd">    has a branch cut `[-inf, -1]` and is continuous from above on it.</span>
<span class="sd">    `log1p` handles the floating-point negative zero as an infinitesimal</span>
<span class="sd">    negative number, conforming to the C99 standard.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] M. Abramowitz and I.A. Stegun, &quot;Handbook of Mathematical Functions&quot;,</span>
<span class="sd">           10th printing, 1964, pp. 67. http://www.math.sfu.ca/~cbm/aands/</span>
<span class="sd">    .. [2] Wikipedia, &quot;Logarithm&quot;. https://en.wikipedia.org/wiki/Logarithm</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.log1p(nps.array(1e-99)).get()  # doctest: +SKIP</span>
<span class="sd">    array(1.e-99)</span>
<span class="sd">    &gt;&gt;&gt; nps.log(nps.array(1 + 1e-99)).get()  # doctest: +SKIP</span>
<span class="sd">    array(0.)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;log1p&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="log2"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.log2.html#nums.numpy.log2">[docs]</a><span class="k">def</span> <span class="nf">log2</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Base-2 logarithm of `x`.</span>

<span class="sd">    This docstring was copied from numpy.log2.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">        Input values.</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray</span>
<span class="sd">        Base-2 logarithm of `x`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    log, log10, log1p</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Logarithm is a multivalued function: for each `x` there is an infinite</span>
<span class="sd">    number of `z` such that `2**z = x`. The convention is to return the `z`</span>
<span class="sd">    whose imaginary part lies in `[-pi, pi]`.</span>

<span class="sd">    For real-valued input data types, `log2` always returns real output.</span>
<span class="sd">    For each value that cannot be expressed as a real number or infinity,</span>
<span class="sd">    it yields ``nan`` and sets the `invalid` floating point error flag.</span>

<span class="sd">    For complex-valued input, `log2` is a complex analytical function that</span>
<span class="sd">    has a branch cut `[-inf, 0]` and is continuous from above on it. `log2`</span>
<span class="sd">    handles the floating-point negative zero as an infinitesimal negative</span>
<span class="sd">    number, conforming to the C99 standard.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; x = nps.array([0, 1, 2, 2**4])  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; nps.log2(x).get()  # doctest: +SKIP</span>
<span class="sd">    array([-Inf,   0.,   1.,   4.])</span>

<span class="sd">    &gt;&gt;&gt; xi = nps.array([0+1.j, 1, 2+0.j, 4.j])  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; nps.log2(xi).get()  # doctest: +SKIP</span>
<span class="sd">    array([ 0.+2.26618007j,  0.+0.j        ,  1.+0.j        ,  2.+2.26618007j])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;log2&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="logical_not"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.logical_not.html#nums.numpy.logical_not">[docs]</a><span class="k">def</span> <span class="nf">logical_not</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Compute the truth value of NOT x element-wise.</span>

<span class="sd">    This docstring was copied from numpy.logical_not.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">        Logical NOT is applied to the elements of `x`.</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray of bool</span>
<span class="sd">        Boolean result with the same shape as `x` of the NOT operation</span>
<span class="sd">        on elements of `x`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    logical_and, logical_or, logical_xor</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.logical_not(nps.array(3)).get()  # doctest: +SKIP</span>
<span class="sd">    array(False)</span>
<span class="sd">    &gt;&gt;&gt; nps.logical_not(nps.array([True, False, 0, 1])).get()  # doctest: +SKIP</span>
<span class="sd">    array([False,  True,  True, False])</span>

<span class="sd">    &gt;&gt;&gt; x = nps.arange(5)  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; nps.logical_not(x&lt;3).get()  # doctest: +SKIP</span>
<span class="sd">    array([False, False, False,  True,  True])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;logical_not&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="negative"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.negative.html#nums.numpy.negative">[docs]</a><span class="k">def</span> <span class="nf">negative</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Numerical negative, element-wise.</span>

<span class="sd">    This docstring was copied from numpy.negative.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray or scalar</span>
<span class="sd">        Input array.</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray or scalar</span>
<span class="sd">        Returned array or scalar: `y = -x`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.negative(nps.array([1.,-1.])).get()  # doctest: +SKIP</span>
<span class="sd">    array([-1.,  1.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;negative&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="positive"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.positive.html#nums.numpy.positive">[docs]</a><span class="k">def</span> <span class="nf">positive</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Numerical positive, element-wise.</span>

<span class="sd">    This docstring was copied from numpy.positive.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">        Input array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray</span>
<span class="sd">        Returned array: `y = +x`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Equivalent to `x.copy()`, but only defined for types that support</span>
<span class="sd">    arithmetic.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;positive&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="rad2deg"><a class="viewcode-back" href="../../../../generated/nums.numpy.api.generated.html#nums.numpy.rad2deg">[docs]</a><span class="k">def</span> <span class="nf">rad2deg</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Convert angles from radians to degrees.</span>

<span class="sd">    This docstring was copied from numpy.rad2deg.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">        Angle in radians.</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray</span>
<span class="sd">        The corresponding angle in degrees.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    deg2rad : Convert angles from degrees to radians.</span>
<span class="sd">    unwrap : Remove large jumps in angle by wrapping.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    rad2deg(x) is ``180 * x / pi``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.rad2deg(nps.array(nps.pi/2)).get()  # doctest: +SKIP</span>
<span class="sd">    array(90.)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;rad2deg&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="radians"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.radians.html#nums.numpy.radians">[docs]</a><span class="k">def</span> <span class="nf">radians</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Convert angles from degrees to radians.</span>

<span class="sd">    This docstring was copied from numpy.radians.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">        Input array in degrees.</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray</span>
<span class="sd">        The corresponding radian values.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    deg2rad : equivalent function</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    Convert a degree array to radians</span>

<span class="sd">    &gt;&gt;&gt; deg = nps.arange(12.) * 30.  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; nps.radians(deg).get()  # doctest: +SKIP</span>
<span class="sd">    array([ 0.        ,  0.52359878,  1.04719755,  1.57079633,  2.0943951 ,</span>
<span class="sd">            2.61799388,  3.14159265,  3.66519143,  4.1887902 ,  4.71238898,</span>
<span class="sd">            5.23598776,  5.75958653])</span>

<span class="sd">    &gt;&gt;&gt; out = nps.zeros((deg.shape))  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; ret = nps.radians(deg, out)  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; ret is out  # doctest: +SKIP</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;radians&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="reciprocal"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.reciprocal.html#nums.numpy.reciprocal">[docs]</a><span class="k">def</span> <span class="nf">reciprocal</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Return the reciprocal of the argument, element-wise.</span>

<span class="sd">    This docstring was copied from numpy.reciprocal.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Calculates ``1/x``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">        Input array.</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray</span>
<span class="sd">        Return array.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    .. note::</span>
<span class="sd">        This function is not designed to work with integers.</span>

<span class="sd">    For integer arguments with absolute value larger than 1 the result is</span>
<span class="sd">    always zero because of the way Python handles integer division.  For</span>
<span class="sd">    integer zero the result is an overflow.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.reciprocal(nps.array(2.)).get()  # doctest: +SKIP</span>
<span class="sd">    array(0.5)</span>
<span class="sd">    &gt;&gt;&gt; nps.reciprocal(nps.array([1, 2., 3.33])).get()  # doctest: +SKIP</span>
<span class="sd">    array([ 1.       ,  0.5      ,  0.3003003])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;reciprocal&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="rint"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.rint.html#nums.numpy.rint">[docs]</a><span class="k">def</span> <span class="nf">rint</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Round elements of the array to the nearest integer.</span>

<span class="sd">    This docstring was copied from numpy.rint.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">        Input array.</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : BlockArray</span>
<span class="sd">        Output array is same shape and type as `x`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ceil, floor, trunc</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; a = nps.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; nps.rint(a).get()  # doctest: +SKIP</span>
<span class="sd">    array([-2., -2., -0.,  0.,  2.,  2.,  2.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;rint&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="sign"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.sign.html#nums.numpy.sign">[docs]</a><span class="k">def</span> <span class="nf">sign</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Returns an element-wise indication of the sign of a number.</span>

<span class="sd">    This docstring was copied from numpy.sign.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    The `sign` function returns ``-1 if x &lt; 0, 0 if x==0, 1 if x &gt; 0``.  nan</span>
<span class="sd">    is returned for nan inputs.</span>

<span class="sd">    For complex inputs, the `sign` function returns</span>
<span class="sd">    ``sign(x.real) + 0j if x.real != 0 else sign(x.imag) + 0j``.</span>

<span class="sd">    complex(nan, 0) is returned for complex nan inputs.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">        Input values.</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray</span>
<span class="sd">        The sign of `x`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    There is more than one definition of sign in common use for complex</span>
<span class="sd">    numbers.  The definition used here is equivalent to :math:`x/\sqrt{x*x}`</span>
<span class="sd">    which is different from a common alternative, :math:`x/|x|`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.sign(nps.array([-5., 4.5])).get()  # doctest: +SKIP</span>
<span class="sd">    array([-1.,  1.])</span>
<span class="sd">    &gt;&gt;&gt; nps.sign(nps.array(0)).get()  # doctest: +SKIP</span>
<span class="sd">    array(0)</span>
<span class="sd">    &gt;&gt;&gt; nps.sign(nps.array(5-2j)).get()  # doctest: +SKIP</span>
<span class="sd">    array(1.+0.j)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;sign&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="signbit"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.signbit.html#nums.numpy.signbit">[docs]</a><span class="k">def</span> <span class="nf">signbit</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Returns element-wise True where signbit is set (less than zero).</span>

<span class="sd">    This docstring was copied from numpy.signbit.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">        The input value(s).</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : BlockArray of bool</span>
<span class="sd">        Output array, or reference to `out` if that was supplied.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.signbit(nps.array(-1.2)).get()  # doctest: +SKIP</span>
<span class="sd">    array(True)</span>
<span class="sd">    &gt;&gt;&gt; nps.signbit(nps.array([1, -2.3, 2.1])).get()  # doctest: +SKIP</span>
<span class="sd">    array([False,  True, False])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;signbit&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="sin"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.sin.html#nums.numpy.sin">[docs]</a><span class="k">def</span> <span class="nf">sin</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Trigonometric sine, element-wise.</span>

<span class="sd">    This docstring was copied from numpy.sin.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">        Angle, in radians (:math:`2 \pi` rad equals 360 degrees).</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray</span>
<span class="sd">        The sine of each element of x.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    arcsin, sinh, cos</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The sine is one of the fundamental functions of trigonometry (the</span>
<span class="sd">    mathematical study of triangles).  Consider a circle of radius 1</span>
<span class="sd">    centered on the origin.  A ray comes in from the :math:`+x` axis, makes</span>
<span class="sd">    an angle at the origin (measured counter-clockwise from that axis), and</span>
<span class="sd">    departs from the origin.  The :math:`y` coordinate of the outgoing</span>
<span class="sd">    ray&#39;s intersection with the unit circle is the sine of that angle.  It</span>
<span class="sd">    ranges from -1 for :math:`x=3\pi / 2` to +1 for :math:`\pi / 2.`  The</span>
<span class="sd">    function has zeroes where the angle is a multiple of :math:`\pi`.</span>
<span class="sd">    Sines of angles between :math:`\pi` and :math:`2\pi` are negative.</span>
<span class="sd">    The numerous properties of the sine and related functions are included</span>
<span class="sd">    in any standard trigonometry text.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    Print sine of one angle:</span>

<span class="sd">    &gt;&gt;&gt; nps.sin(nps.array(nps.pi/2.)).get()  # doctest: +SKIP</span>
<span class="sd">    array(1.)</span>

<span class="sd">    Print sines of an array of angles given in degrees:</span>

<span class="sd">    &gt;&gt;&gt; nps.sin(nps.array((0., 30., 45., 60., 90.)) * nps.pi / 180. ).get()  # doctest: +SKIP</span>
<span class="sd">    array([ 0.        ,  0.5       ,  0.70710678,  0.8660254 ,  1.        ])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;sin&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="sinh"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.sinh.html#nums.numpy.sinh">[docs]</a><span class="k">def</span> <span class="nf">sinh</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Hyperbolic sine, element-wise.</span>

<span class="sd">    This docstring was copied from numpy.sinh.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Equivalent to ``1/2 * (nps.exp(x) - nps.exp(-x)).get()`` or</span>
<span class="sd">    ``-1j * nps.sin(1j*x).get()``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">        Input array.</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray</span>
<span class="sd">        The corresponding hyperbolic sine values.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If `out` is provided, the function writes the result into it,</span>
<span class="sd">    and returns a reference to `out`.  (See Examples)</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.</span>
<span class="sd">    New York, NY: Dover, 1972, pg. 83.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.sinh(nps.array(0)).get()  # doctest: +SKIP</span>
<span class="sd">    nps.array(0.)</span>
<span class="sd">    &gt;&gt;&gt; nps.sinh(nps.array(nps.pi*1j/2)).get()  # doctest: +SKIP</span>
<span class="sd">    array(0.+1.j)</span>
<span class="sd">    &gt;&gt;&gt; nps.sinh(nps.array(nps.pi*1j)).get() # (exact value is 0)  # doctest: +SKIP</span>
<span class="sd">    array(0.+1.2246468e-16j)</span>
<span class="sd">    &gt;&gt;&gt; # Discrepancy due to vagaries of floating point arithmetic.</span>

<span class="sd">    &gt;&gt;&gt; # Example of providing the optional output parameter</span>
<span class="sd">    &gt;&gt;&gt; out1 = nps.array([0], dtype=&#39;d&#39;)  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; out2 = nps.sinh(nps.array([0.1]), out1)  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; out2 is out1  # doctest: +SKIP</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;sinh&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="spacing"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.spacing.html#nums.numpy.spacing">[docs]</a><span class="k">def</span> <span class="nf">spacing</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Return the distance between x and the nearest adjacent number.</span>

<span class="sd">    This docstring was copied from numpy.spacing.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">        Values to find the spacing of.</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : BlockArray or scalar</span>
<span class="sd">        The spacing of values of `x`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;spacing&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="sqrt"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.sqrt.html#nums.numpy.sqrt">[docs]</a><span class="k">def</span> <span class="nf">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Return the non-negative square-root of an array, element-wise.</span>

<span class="sd">    This docstring was copied from numpy.sqrt.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">        The values whose square-roots are required.</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray</span>
<span class="sd">        An array of the same shape as `x`, containing the positive</span>
<span class="sd">        square-root of each element in `x`.  If any element in `x` is</span>
<span class="sd">        complex, a complex array is returned (and the square-roots of</span>
<span class="sd">        negative reals are calculated).  If all of the elements in `x`</span>
<span class="sd">        are real, so is `y`, with negative elements returning ``nan``.</span>
<span class="sd">        If `out` was provided, `y` is a reference to it.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    *sqrt* has--consistent with common convention--as its branch cut the</span>
<span class="sd">    real &quot;interval&quot; [`-inf`, 0), and is continuous from above on it.</span>
<span class="sd">    A branch cut is a curve in the complex plane across which a given</span>
<span class="sd">    complex function fails to be continuous.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.sqrt(nps.array([1,4,9])).get()  # doctest: +SKIP</span>
<span class="sd">    array([ 1.,  2.,  3.])</span>

<span class="sd">    &gt;&gt;&gt; nps.sqrt(nps.array([4, -1, -3+4J])).get()  # doctest: +SKIP</span>
<span class="sd">    array([ 2.+0.j,  0.+1.j,  1.+2.j])</span>

<span class="sd">    &gt;&gt;&gt; nps.sqrt(nps.array([4, -1, nps.inf])).get()  # doctest: +SKIP</span>
<span class="sd">    array([ 2., nan, inf])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;sqrt&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="square"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.square.html#nums.numpy.square">[docs]</a><span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Return the element-wise square of the input.</span>

<span class="sd">    This docstring was copied from numpy.square.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">        Input data.</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : BlockArray or scalar</span>
<span class="sd">        Element-wise `x*x`, of the same shape and dtype as `x`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    sqrt</span>
<span class="sd">    power</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.square(nps.array([-1j, 1])).get()  # doctest: +SKIP</span>
<span class="sd">    array([-1.-0.j,  1.+0.j])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;square&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="tan"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.tan.html#nums.numpy.tan">[docs]</a><span class="k">def</span> <span class="nf">tan</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Compute tangent element-wise.</span>

<span class="sd">    This docstring was copied from numpy.tan.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Equivalent to ``nps.sin(x)/nps.cos(x).get()`` element-wise.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">        Input array.</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray</span>
<span class="sd">        The corresponding tangent values.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If `out` is provided, the function writes the result into it,</span>
<span class="sd">    and returns a reference to `out`.  (See Examples)</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.</span>
<span class="sd">    New York, NY: Dover, 1972.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; from math import pi  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; nps.tan(nps.array([-pi,pi/2,pi])).get()  # doctest: +SKIP</span>
<span class="sd">    array([  1.22460635e-16,   1.63317787e+16,  -1.22460635e-16])</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Example of providing the optional output parameter illustrating</span>
<span class="sd">    &gt;&gt;&gt; # that what is returned is a reference to said parameter</span>
<span class="sd">    &gt;&gt;&gt; out1 = nps.array([0], dtype=&#39;d&#39;)  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; out2 = nps.cos(nps.array([0.1]), out1)  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; out2 is out1  # doctest: +SKIP</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;tan&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="tanh"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.tanh.html#nums.numpy.tanh">[docs]</a><span class="k">def</span> <span class="nf">tanh</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Compute hyperbolic tangent element-wise.</span>

<span class="sd">    This docstring was copied from numpy.tanh.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Equivalent to ``nps.sinh(x)/nps.cosh(x)`` or ``-1j * nps.tan(1j*x).get()``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">        Input array.</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray</span>
<span class="sd">        The corresponding hyperbolic tangent values.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If `out` is provided, the function writes the result into it,</span>
<span class="sd">    and returns a reference to `out`.  (See Examples)</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.</span>
<span class="sd">           New York, NY: Dover, 1972, pg. 83.</span>
<span class="sd">           http://www.math.sfu.ca/~cbm/aands/</span>

<span class="sd">    .. [2] Wikipedia, &quot;Hyperbolic function&quot;,</span>
<span class="sd">           https://en.wikipedia.org/wiki/Hyperbolic_function</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.tanh(nps.array([0, nps.pi*1j, nps.pi*1j/2])).get()  # doctest: +SKIP</span>
<span class="sd">    array([ 0. +0.00000000e+00j,  0. -1.22460635e-16j,  0. +1.63317787e+16j])</span>

<span class="sd">    &gt;&gt;&gt; # Example of providing the optional output parameter illustrating</span>
<span class="sd">    &gt;&gt;&gt; # that what is returned is a reference to said parameter</span>
<span class="sd">    &gt;&gt;&gt; out1 = nps.array([0], dtype=&#39;d&#39;)  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; out2 = nps.tanh(nps.array([0.1]), out1)  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; out2 is out1  # doctest: +SKIP</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;tanh&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="trunc"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.trunc.html#nums.numpy.trunc">[docs]</a><span class="k">def</span> <span class="nf">trunc</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Return the truncated value of the input, element-wise.</span>

<span class="sd">    This docstring was copied from numpy.trunc.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    The truncated value of the scalar `x` is the nearest integer `i` which</span>
<span class="sd">    is closer to zero than `x` is. In short, the fractional part of the</span>
<span class="sd">    signed number `x` is discarded.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : BlockArray</span>
<span class="sd">        Input data.</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray</span>
<span class="sd">        The truncated value of each element in `x`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ceil, floor, rint</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; a = nps.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; nps.trunc(a).get()  # doctest: +SKIP</span>
<span class="sd">    array([-1., -1., -0.,  0.,  1.,  1.,  2.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_uop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;trunc&quot;</span><span class="p">,</span>
        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="add"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.add.html#nums.numpy.add">[docs]</a><span class="k">def</span> <span class="nf">add</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Add arguments element-wise.</span>

<span class="sd">    This docstring was copied from numpy.add.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1, x2 : BlockArray</span>
<span class="sd">        The arrays to be added.</span>
<span class="sd">        If ``x1.shape != x2.shape``, they must be broadcastable to a common</span>
<span class="sd">        shape (which becomes the shape of the output).</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    add : BlockArray or scalar</span>
<span class="sd">        The sum of `x1` and `x2`, element-wise.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Equivalent to `x1` + `x2` in terms of array broadcasting.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.add(nps.array(1.0), nps.array(4.0)).get()  # doctest: +SKIP</span>
<span class="sd">    array(5.)</span>
<span class="sd">    &gt;&gt;&gt; x1 = nps.arange(9.0).reshape((3, 3))  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; x2 = nps.arange(3.0)  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; nps.add(x1, x2).get()  # doctest: +SKIP</span>
<span class="sd">    array([[  0.,   2.,   4.],</span>
<span class="sd">           [  3.,   5.,   7.],</span>
<span class="sd">           [  6.,   8.,  10.]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_bop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;add&quot;</span><span class="p">,</span>
        <span class="n">arr_1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span>
        <span class="n">arr_2</span><span class="o">=</span><span class="n">x2</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="arctan2"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.arctan2.html#nums.numpy.arctan2">[docs]</a><span class="k">def</span> <span class="nf">arctan2</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Element-wise arc tangent of ``x1/x2`` choosing the quadrant correctly.</span>

<span class="sd">    This docstring was copied from numpy.arctan2.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    The quadrant (i.e., branch) is chosen so that ``arctan2(x1, x2)`` is</span>
<span class="sd">    the signed angle in radians between the ray ending at the origin and</span>
<span class="sd">    passing through the point (1,0), and the ray ending at the origin and</span>
<span class="sd">    passing through the point (`x2`, `x1`).  (Note the role reversal: the</span>
<span class="sd">    &quot;`y`-coordinate&quot; is the first function parameter, the &quot;`x`-coordinate&quot;</span>
<span class="sd">    is the second.)  By IEEE convention, this function is defined for</span>
<span class="sd">    `x2` = +/-0 and for either or both of `x1` and `x2` = +/-inf (see</span>
<span class="sd">    Notes for specific values).</span>

<span class="sd">    This function is not defined for complex-valued arguments; for the</span>
<span class="sd">    so-called argument of complex values, use `angle`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1 : BlockArray, real-valued</span>
<span class="sd">        `y`-coordinates.</span>
<span class="sd">    x2 : BlockArray, real-valued</span>
<span class="sd">        `x`-coordinates.</span>
<span class="sd">        If ``x1.shape != x2.shape``, they must be broadcastable to a common</span>
<span class="sd">        shape (which becomes the shape of the output).</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    angle : BlockArray</span>
<span class="sd">        Array of angles in radians, in the range ``[-pi, pi]``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    arctan, tan, angle</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    *arctan2* is identical to the `atan2` function of the underlying</span>
<span class="sd">    C library.  The following special values are defined in the C</span>
<span class="sd">    standard: [1]_</span>

<span class="sd">    ====== ====== ================</span>
<span class="sd">    `x1`   `x2`   `arctan2(x1,x2)`</span>
<span class="sd">    ====== ====== ================</span>
<span class="sd">    +/- 0  +0     +/- 0</span>
<span class="sd">    +/- 0  -0     +/- pi</span>
<span class="sd">     &gt; 0   +/-inf +0 / +pi</span>
<span class="sd">     &lt; 0   +/-inf -0 / -pi</span>
<span class="sd">    +/-inf +inf   +/- (pi/4)</span>
<span class="sd">    +/-inf -inf   +/- (3*pi/4)</span>
<span class="sd">    ====== ====== ================</span>

<span class="sd">    Note that +0 and -0 are distinct floating point numbers, as are +inf</span>
<span class="sd">    and -inf.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] ISO/IEC standard 9899:1999, &quot;Programming language C.&quot;</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    Consider four points in different quadrants:</span>

<span class="sd">    &gt;&gt;&gt; x = nps.array([-1, +1, +1, -1])  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; y = nps.array([-1, -1, +1, +1])  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; (nps.arctan2(y, x) * 180 / nps.pi).get()  # doctest: +SKIP</span>
<span class="sd">    array([-135.,  -45.,   45.,  135.])</span>

<span class="sd">    Note the order of the parameters. `arctan2` is defined also when `x2` = 0</span>
<span class="sd">    and at several other special points, obtaining values in</span>
<span class="sd">    the range ``[-pi, pi]``:</span>

<span class="sd">    &gt;&gt;&gt; nps.arctan2(nps.array([1., -1.]), nps.array([0., 0.])).get()  # doctest: +SKIP</span>
<span class="sd">    array([ 1.57079633, -1.57079633])</span>
<span class="sd">    &gt;&gt;&gt; nps.arctan2(nps.array([0., 0., nps.inf]),</span>
<span class="sd">    ...     nps.array([+0., -0., nps.inf])).get()  # doctest: +SKIP</span>
<span class="sd">    array([ 0.        ,  3.14159265,  0.78539816])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_bop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;arctan2&quot;</span><span class="p">,</span>
        <span class="n">arr_1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span>
        <span class="n">arr_2</span><span class="o">=</span><span class="n">x2</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="bitwise_and"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.bitwise_and.html#nums.numpy.bitwise_and">[docs]</a><span class="k">def</span> <span class="nf">bitwise_and</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Compute the bit-wise AND of two arrays element-wise.</span>

<span class="sd">    This docstring was copied from numpy.bitwise_and.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Computes the bit-wise AND of the underlying binary representation of</span>
<span class="sd">    the integers in the input arrays. This ufunc implements the C/Python</span>
<span class="sd">    operator ``&amp;``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1, x2 : BlockArray</span>
<span class="sd">        Only integer and boolean types are handled.</span>
<span class="sd">        If ``x1.shape != x2.shape``, they must be broadcastable to a common</span>
<span class="sd">        shape (which becomes the shape of the output).</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : BlockArray or scalar</span>
<span class="sd">        Result.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    logical_and</span>
<span class="sd">    bitwise_or</span>
<span class="sd">    bitwise_xor</span>
<span class="sd">    binary_repr :</span>
<span class="sd">        Return the binary representation of the input number as a string.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    number 13 is represented by ``00001101``.  Likewise, 17 is</span>
<span class="sd">    represented by ``00010001``.  The bit-wise AND of 13 and 17 is</span>
<span class="sd">    therefore ``000000001``, or 1:</span>

<span class="sd">    &gt;&gt;&gt; nps.bitwise_and(nps.array(13), nps.array(17)).get()  # doctest: +SKIP</span>
<span class="sd">    array(1)</span>
<span class="sd">    &gt;&gt;&gt; nps.bitwise_and(nps.array([2,5,255]), nps.array([3,14,16])).get()  # doctest: +SKIP</span>
<span class="sd">    array([ 2,  4, 16])</span>
<span class="sd">    &gt;&gt;&gt; nps.bitwise_and(nps.array([True, True]), nps.array([False, True])).get()  # doctest: +SKIP</span>
<span class="sd">    array([False,  True])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_bop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;bitwise_and&quot;</span><span class="p">,</span>
        <span class="n">arr_1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span>
        <span class="n">arr_2</span><span class="o">=</span><span class="n">x2</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="bitwise_or"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.bitwise_or.html#nums.numpy.bitwise_or">[docs]</a><span class="k">def</span> <span class="nf">bitwise_or</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Compute the bit-wise OR of two arrays element-wise.</span>

<span class="sd">    This docstring was copied from numpy.bitwise_or.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Computes the bit-wise OR of the underlying binary representation of</span>
<span class="sd">    the integers in the input arrays. This ufunc implements the C/Python</span>
<span class="sd">    operator ``|``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1, x2 : BlockArray</span>
<span class="sd">        Only integer and boolean types are handled.</span>
<span class="sd">        If ``x1.shape != x2.shape``, they must be broadcastable to a common</span>
<span class="sd">        shape (which becomes the shape of the output).</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : BlockArray</span>
<span class="sd">        Result.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    logical_or</span>
<span class="sd">    bitwise_and</span>
<span class="sd">    bitwise_xor</span>
<span class="sd">    binary_repr :</span>
<span class="sd">        Return the binary representation of the input number as a string.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    number 13 has the binaray representation ``00001101``. Likewise,</span>
<span class="sd">    16 is represented by ``00010000``.  The bit-wise OR of 13 and 16 is</span>
<span class="sd">    then ``000111011``, or 29:</span>

<span class="sd">    &gt;&gt;&gt; nps.bitwise_or(nps.array(13), nps.array(16)).get()  # doctest: +SKIP</span>
<span class="sd">    array(29)</span>
<span class="sd">    &gt;&gt;&gt; nps.bitwise_or(nps.array([2, 5, 255]), nps.array([4, 4, 4])).get()  # doctest: +SKIP</span>
<span class="sd">    array([  6,   5, 255])</span>
<span class="sd">    &gt;&gt;&gt; (nps.array([2, 5, 255]) | nps.array([4, 4, 4])).get()  # doctest: +SKIP</span>
<span class="sd">    array([  6,   5, 255])</span>
<span class="sd">    &gt;&gt;&gt; nps.bitwise_or(nps.array([True, True]), nps.array([False, True])).get()  # doctest: +SKIP</span>
<span class="sd">    array([ True,  True])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_bop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;bitwise_or&quot;</span><span class="p">,</span>
        <span class="n">arr_1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span>
        <span class="n">arr_2</span><span class="o">=</span><span class="n">x2</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="bitwise_xor"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.bitwise_xor.html#nums.numpy.bitwise_xor">[docs]</a><span class="k">def</span> <span class="nf">bitwise_xor</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Compute the bit-wise XOR of two arrays element-wise.</span>

<span class="sd">    This docstring was copied from numpy.bitwise_xor.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Computes the bit-wise XOR of the underlying binary representation of</span>
<span class="sd">    the integers in the input arrays. This ufunc implements the C/Python</span>
<span class="sd">    operator ``^``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1, x2 : BlockArray</span>
<span class="sd">        Only integer and boolean types are handled.</span>
<span class="sd">        If ``x1.shape != x2.shape``, they must be broadcastable to a common</span>
<span class="sd">        shape (which becomes the shape of the output).</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : BlockArray</span>
<span class="sd">        Result.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    logical_xor</span>
<span class="sd">    bitwise_and</span>
<span class="sd">    bitwise_or</span>
<span class="sd">    binary_repr :</span>
<span class="sd">        Return the binary representation of the input number as a string.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    number 13 is represented by ``00001101``. Likewise, 17 is</span>
<span class="sd">    represented by ``00010001``.  The bit-wise XOR of 13 and 17 is</span>
<span class="sd">    therefore ``00011100``, or 28:</span>

<span class="sd">    &gt;&gt;&gt; nps.bitwise_xor(nps.array(13), nps.array(17)).get()  # doctest: +SKIP</span>
<span class="sd">    nps.array(28)</span>

<span class="sd">    &gt;&gt;&gt; nps.bitwise_xor(nps.array([31,3]), nps.array([5,6])).get()  # doctest: +SKIP</span>
<span class="sd">    array([26,  5])</span>
<span class="sd">    &gt;&gt;&gt; nps.bitwise_xor(nps.array([True, True]), nps.array([False, True])).get()  # doctest: +SKIP</span>
<span class="sd">    array([ True, False])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_bop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;bitwise_xor&quot;</span><span class="p">,</span>
        <span class="n">arr_1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span>
        <span class="n">arr_2</span><span class="o">=</span><span class="n">x2</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="copysign"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.copysign.html#nums.numpy.copysign">[docs]</a><span class="k">def</span> <span class="nf">copysign</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Change the sign of x1 to that of x2, element-wise.</span>

<span class="sd">    This docstring was copied from numpy.copysign.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    If `x2` is a scalar, its sign will be copied to all elements of `x1`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1 : BlockArray</span>
<span class="sd">        Values to change the sign of.</span>
<span class="sd">    x2 : BlockArray</span>
<span class="sd">        The sign of `x2` is copied to `x1`.</span>
<span class="sd">        If ``x1.shape != x2.shape``, they must be broadcastable to a common</span>
<span class="sd">        shape (which becomes the shape of the output).</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : BlockArray</span>
<span class="sd">        The values of `x1` with the sign of `x2`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.copysign(nps.array(1.3), nps.array(-1)).get()  # doctest: +SKIP</span>
<span class="sd">    array(-1.3)</span>
<span class="sd">    &gt;&gt;&gt; (1/nps.copysign(nps.array(0), nps.array(1))).get()  # doctest: +SKIP</span>
<span class="sd">    array(inf)</span>
<span class="sd">    &gt;&gt;&gt; (1/nps.copysign(nps.array(0), nps.array(-1))).get()  # doctest: +SKIP</span>
<span class="sd">    array(-inf)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_bop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;copysign&quot;</span><span class="p">,</span>
        <span class="n">arr_1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span>
        <span class="n">arr_2</span><span class="o">=</span><span class="n">x2</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="divide"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.divide.html#nums.numpy.divide">[docs]</a><span class="k">def</span> <span class="nf">divide</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Returns a true division of the inputs, element-wise.</span>

<span class="sd">    This docstring was copied from numpy.divide.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Instead of the Python traditional &#39;floor division&#39;, this returns a true</span>
<span class="sd">    division.  True division adjusts the output type to present the best</span>
<span class="sd">    answer, regardless of input types.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1 : BlockArray</span>
<span class="sd">        Dividend array.</span>
<span class="sd">    x2 : BlockArray</span>
<span class="sd">        Divisor array.</span>
<span class="sd">        If ``x1.shape != x2.shape``, they must be broadcastable to a common</span>
<span class="sd">        shape (which becomes the shape of the output).</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : BlockArray or scalar</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    In Python, ``//`` is the floor division operator and ``/`` the</span>
<span class="sd">    true division operator.  The ``true_divide(x1, x2)`` function is</span>
<span class="sd">    equivalent to true division in Python.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; x = nps.arange(5)  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; nps.true_divide(x, nps.array(4)).get()  # doctest: +SKIP</span>
<span class="sd">    array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])</span>

<span class="sd">    &gt;&gt;&gt; (x/4).get()  # doctest: +SKIP</span>
<span class="sd">    array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_bop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;divide&quot;</span><span class="p">,</span>
        <span class="n">arr_1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span>
        <span class="n">arr_2</span><span class="o">=</span><span class="n">x2</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="equal"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.equal.html#nums.numpy.equal">[docs]</a><span class="k">def</span> <span class="nf">equal</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Return (x1 == x2) element-wise.</span>

<span class="sd">    This docstring was copied from numpy.equal.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1, x2 : BlockArray</span>
<span class="sd">        Input arrays.</span>
<span class="sd">        If ``x1.shape != x2.shape``, they must be broadcastable to a common</span>
<span class="sd">        shape (which becomes the shape of the output).</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : BlockArray</span>
<span class="sd">        Output array, element-wise comparison of `x1` and `x2`.</span>
<span class="sd">        Typically of type bool, unless ``dtype=object`` is passed.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    not_equal, greater_equal, less_equal, greater, less</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.equal(nps.array([0, 1, 3]), nps.arange(3)).get()  # doctest: +SKIP</span>
<span class="sd">    array([ True,  True, False])</span>

<span class="sd">    What is compared are values, not types. So an int (1) and an array of</span>
<span class="sd">    length one can evaluate as True:</span>

<span class="sd">    &gt;&gt;&gt; nps.equal(nps.array(1), nps.ones(1)).get()  # doctest: +SKIP</span>
<span class="sd">    array([ True])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_bop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;equal&quot;</span><span class="p">,</span>
        <span class="n">arr_1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span>
        <span class="n">arr_2</span><span class="o">=</span><span class="n">x2</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="float_power"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.float_power.html#nums.numpy.float_power">[docs]</a><span class="k">def</span> <span class="nf">float_power</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;First array elements raised to powers from second array, element-wise.</span>

<span class="sd">    This docstring was copied from numpy.float_power.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Raise each base in `x1` to the positionally-corresponding power in `x2`.</span>
<span class="sd">    `x1` and `x2` must be broadcastable to the same shape. This differs from</span>
<span class="sd">    the power function in that integers, float16, and float32  are promoted to</span>
<span class="sd">    floats with a minimum precision of float64 so that the result is always</span>
<span class="sd">    inexact.  The intent is that the function will return a usable result for</span>
<span class="sd">    negative powers and seldom overflow for positive powers.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1 : BlockArray</span>
<span class="sd">        The bases.</span>
<span class="sd">    x2 : BlockArray</span>
<span class="sd">        The exponents.</span>
<span class="sd">        If ``x1.shape != x2.shape``, they must be broadcastable to a common</span>
<span class="sd">        shape (which becomes the shape of the output).</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray</span>
<span class="sd">        The bases in `x1` raised to the exponents in `x2`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    power : power function that preserves type</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_bop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;float_power&quot;</span><span class="p">,</span>
        <span class="n">arr_1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span>
        <span class="n">arr_2</span><span class="o">=</span><span class="n">x2</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="floor_divide"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.floor_divide.html#nums.numpy.floor_divide">[docs]</a><span class="k">def</span> <span class="nf">floor_divide</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Return the largest integer smaller or equal to the division of the inputs.</span>
<span class="sd">    It is equivalent to the Python ``//`` operator and pairs with the</span>
<span class="sd">    Python ``%`` (`remainder`), function so that ``a = a % b + b * (a // b)``</span>
<span class="sd">    up to roundoff.</span>

<span class="sd">    This docstring was copied from numpy.floor_divide.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1 : BlockArray</span>
<span class="sd">        Numerator.</span>
<span class="sd">    x2 : BlockArray</span>
<span class="sd">        Denominator.</span>
<span class="sd">        If ``x1.shape != x2.shape``, they must be broadcastable to a common</span>
<span class="sd">        shape (which becomes the shape of the output).</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray</span>
<span class="sd">        y = floor(`x1`/`x2`)</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    remainder : Remainder complementary to floor_divide.</span>
<span class="sd">    divmod : Simultaneous floor division and remainder.</span>
<span class="sd">    divide : Standard division.</span>
<span class="sd">    floor : Round a number to the nearest integer toward minus infinity.</span>
<span class="sd">    ceil : Round a number to the nearest integer toward infinity.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.floor_divide(nps.array(7),nps.array(3)).get()  # doctest: +SKIP</span>
<span class="sd">    nps.array(2)</span>
<span class="sd">    &gt;&gt;&gt; nps.floor_divide(nps.array([1., 2., 3., 4.]), nps.array(2.5)).get()  # doctest: +SKIP</span>
<span class="sd">    array([ 0.,  0.,  1.,  1.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_bop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;floor_divide&quot;</span><span class="p">,</span>
        <span class="n">arr_1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span>
        <span class="n">arr_2</span><span class="o">=</span><span class="n">x2</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="fmax"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.fmax.html#nums.numpy.fmax">[docs]</a><span class="k">def</span> <span class="nf">fmax</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Element-wise maximum of array elements.</span>

<span class="sd">    This docstring was copied from numpy.fmax.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Compare two arrays and returns a new array containing the element-wise</span>
<span class="sd">    maxima. If one of the elements being compared is a NaN, then the</span>
<span class="sd">    non-nan element is returned. If both elements are NaNs then the first</span>
<span class="sd">    is returned.  The latter distinction is important for complex NaNs,</span>
<span class="sd">    which are defined as at least one of the real or imaginary parts being</span>
<span class="sd">    a NaN. The net effect is that NaNs are ignored when possible.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1, x2 : BlockArray</span>
<span class="sd">        The arrays holding the elements to be compared.</span>
<span class="sd">        If ``x1.shape != x2.shape``, they must be broadcastable to a common</span>
<span class="sd">        shape (which becomes the shape of the output).</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray</span>
<span class="sd">        The maximum of `x1` and `x2`, element-wise.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    fmin :</span>
<span class="sd">        Element-wise minimum of two arrays, ignores NaNs.</span>
<span class="sd">    maximum :</span>
<span class="sd">        Element-wise maximum of two arrays, propagates NaNs.</span>
<span class="sd">    amax :</span>
<span class="sd">        The maximum value of an array along a given axis, propagates NaNs.</span>
<span class="sd">    nanmax :</span>
<span class="sd">        The maximum value of an array along a given axis, ignores NaNs.</span>

<span class="sd">    minimum, amin, nanmin</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The fmax is equivalent to ``nps.where(x1 &gt;= x2, x1, x2).get()`` when neither</span>
<span class="sd">    x1 nor x2 are NaNs, but it is faster and does proper broadcasting.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.fmax(nps.array([2, 3, 4]), nps.array([1, 5, 2])).get()  # doctest: +SKIP</span>
<span class="sd">    array([ 2.,  5.,  4.])</span>

<span class="sd">    &gt;&gt;&gt; nps.fmax(nps.eye(2), nps.array([0.5, 2])).get()  # doctest: +SKIP</span>
<span class="sd">    array([[ 1. ,  2. ],</span>
<span class="sd">           [ 0.5,  2. ]])</span>

<span class="sd">    &gt;&gt;&gt; nps.fmax(nps.array([nps.nan, 0, nps.nan]),</span>
<span class="sd">    ...     nps.array([0, nps.nan, nps.nan])).get()  # doctest: +SKIP</span>
<span class="sd">    array([ 0.,  0., nan])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_bop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;fmax&quot;</span><span class="p">,</span>
        <span class="n">arr_1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span>
        <span class="n">arr_2</span><span class="o">=</span><span class="n">x2</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="fmin"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.fmin.html#nums.numpy.fmin">[docs]</a><span class="k">def</span> <span class="nf">fmin</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Element-wise minimum of array elements.</span>

<span class="sd">    This docstring was copied from numpy.fmin.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Compare two arrays and returns a new array containing the element-wise</span>
<span class="sd">    minima. If one of the elements being compared is a NaN, then the</span>
<span class="sd">    non-nan element is returned. If both elements are NaNs then the first</span>
<span class="sd">    is returned.  The latter distinction is important for complex NaNs,</span>
<span class="sd">    which are defined as at least one of the real or imaginary parts being</span>
<span class="sd">    a NaN. The net effect is that NaNs are ignored when possible.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1, x2 : BlockArray</span>
<span class="sd">        The arrays holding the elements to be compared.</span>
<span class="sd">        If ``x1.shape != x2.shape``, they must be broadcastable to a common</span>
<span class="sd">        shape (which becomes the shape of the output).</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray</span>
<span class="sd">        The minimum of `x1` and `x2`, element-wise.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    fmax :</span>
<span class="sd">        Element-wise maximum of two arrays, ignores NaNs.</span>
<span class="sd">    minimum :</span>
<span class="sd">        Element-wise minimum of two arrays, propagates NaNs.</span>
<span class="sd">    amin :</span>
<span class="sd">        The minimum value of an array along a given axis, propagates NaNs.</span>
<span class="sd">    nanmin :</span>
<span class="sd">        The minimum value of an array along a given axis, ignores NaNs.</span>

<span class="sd">    maximum, amax, nanmax</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The fmin is equivalent to ``nps.where(x1 &lt;= x2, x1, x2).get()`` when neither</span>
<span class="sd">    x1 nor x2 are NaNs, but it is faster and does proper broadcasting.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.fmin(nps.array([2, 3, 4]), nps.array([1, 5, 2])).get()  # doctest: +SKIP</span>
<span class="sd">    array([1, 3, 2])</span>

<span class="sd">    &gt;&gt;&gt; nps.fmin(nps.eye(2), nps.array([0.5, 2])).get()  # doctest: +SKIP</span>
<span class="sd">    array([[ 0.5,  0. ],</span>
<span class="sd">           [ 0. ,  1. ]])</span>

<span class="sd">    &gt;&gt;&gt; nps.fmin(nps.array([nps.nan, 0, nps.nan]),</span>
<span class="sd">    ...     nps.array([0, nps.nan, nps.nan])).get()  # doctest: +SKIP</span>
<span class="sd">    array([ 0.,  0., nan])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_bop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;fmin&quot;</span><span class="p">,</span>
        <span class="n">arr_1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span>
        <span class="n">arr_2</span><span class="o">=</span><span class="n">x2</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="fmod"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.fmod.html#nums.numpy.fmod">[docs]</a><span class="k">def</span> <span class="nf">fmod</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Return the element-wise remainder of division.</span>

<span class="sd">    This docstring was copied from numpy.fmod.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    This is the NumPy implementation of the C library function fmod, the</span>
<span class="sd">    remainder has the same sign as the dividend `x1`. It is equivalent to</span>
<span class="sd">    the Matlab(TM) ``rem`` function and should not be confused with the</span>
<span class="sd">    Python modulus operator ``x1 % x2``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1 : BlockArray</span>
<span class="sd">        Dividend.</span>
<span class="sd">    x2 : BlockArray</span>
<span class="sd">        Divisor.</span>
<span class="sd">        If ``x1.shape != x2.shape``, they must be broadcastable to a common</span>
<span class="sd">        shape (which becomes the shape of the output).</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray</span>
<span class="sd">        The remainder of the division of `x1` by `x2`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    remainder : Equivalent to the Python ``%`` operator.</span>
<span class="sd">    divide</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The result of the modulo operation for negative dividend and divisors</span>
<span class="sd">    is bound by conventions. For `fmod`, the sign of result is the sign of</span>
<span class="sd">    the dividend, while for `remainder` the sign of the result is the sign</span>
<span class="sd">    of the divisor. The `fmod` function is equivalent to the Matlab(TM)</span>
<span class="sd">    ``rem`` function.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.fmod(nps.array([-3, -2, -1, 1, 2, 3]), nps.array(2)).get()  # doctest: +SKIP</span>
<span class="sd">    array([-1,  0, -1,  1,  0,  1])</span>
<span class="sd">    &gt;&gt;&gt; nps.remainder(nps.array([-3, -2, -1, 1, 2, 3]), nps.array(2)).get()  # doctest: +SKIP</span>
<span class="sd">    array([1, 0, 1, 1, 0, 1])</span>

<span class="sd">    &gt;&gt;&gt; nps.fmod(nps.array([5, 3]), nps.array([2, 2.])).get()  # doctest: +SKIP</span>
<span class="sd">    array([ 1.,  1.])</span>
<span class="sd">    &gt;&gt;&gt; a = nps.arange(-3, 3).reshape(3, 2)  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; a.get()  # doctest: +SKIP</span>
<span class="sd">    array([[-3, -2],</span>
<span class="sd">           [-1,  0],</span>
<span class="sd">           [ 1,  2]])</span>
<span class="sd">    &gt;&gt;&gt; nps.fmod(a, nps.array([2,2])).get()  # doctest: +SKIP</span>
<span class="sd">    array([[-1,  0],</span>
<span class="sd">           [-1,  0],</span>
<span class="sd">           [ 1,  0]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_bop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;fmod&quot;</span><span class="p">,</span>
        <span class="n">arr_1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span>
        <span class="n">arr_2</span><span class="o">=</span><span class="n">x2</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="gcd"><a class="viewcode-back" href="../../../../generated/nums.numpy.api.generated.html#nums.numpy.gcd">[docs]</a><span class="k">def</span> <span class="nf">gcd</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Returns the greatest common divisor of ``|x1|`` and ``|x2|``</span>

<span class="sd">    This docstring was copied from numpy.gcd.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1, x2 : BlockArray, int</span>
<span class="sd">        Arrays of values.</span>
<span class="sd">        If ``x1.shape != x2.shape``, they must be broadcastable to a common</span>
<span class="sd">        shape (which becomes the shape of the output).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray</span>
<span class="sd">        The greatest common divisor of the absolute value of the inputs</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    lcm : The lowest common multiple</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.gcd(nps.array(12), nps.array(20)).get()  # doctest: +SKIP</span>
<span class="sd">    array(4)</span>
<span class="sd">    &gt;&gt;&gt; nps.gcd(nps.arange(6), nps.array(20)).get()  # doctest: +SKIP</span>
<span class="sd">    array([20,  1,  2,  1,  4,  5])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_bop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;gcd&quot;</span><span class="p">,</span>
        <span class="n">arr_1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span>
        <span class="n">arr_2</span><span class="o">=</span><span class="n">x2</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="greater"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.greater.html#nums.numpy.greater">[docs]</a><span class="k">def</span> <span class="nf">greater</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Return the truth value of (x1 &gt; x2) element-wise.</span>

<span class="sd">    This docstring was copied from numpy.greater.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1, x2 : BlockArray</span>
<span class="sd">        Input arrays.</span>
<span class="sd">        If ``x1.shape != x2.shape``, they must be broadcastable to a common</span>
<span class="sd">        shape (which becomes the shape of the output).</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : BlockArray</span>
<span class="sd">        Output array, element-wise comparison of `x1` and `x2`.</span>
<span class="sd">        Typically of type bool, unless ``dtype=object`` is passed.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    greater_equal, less, less_equal, equal, not_equal</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.greater(nps.array([4,2]),nps.array([2,2])).get()  # doctest: +SKIP</span>
<span class="sd">    array([ True, False])</span>

<span class="sd">    If the inputs are BlockArray, then nps.greater is equivalent to &#39;&gt;&#39;.</span>

<span class="sd">    &gt;&gt;&gt; a = nps.array([4,2])  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; b = nps.array([2,2])  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; (a &gt; b).get()  # doctest: +SKIP</span>
<span class="sd">    array([ True, False])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_bop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;greater&quot;</span><span class="p">,</span>
        <span class="n">arr_1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span>
        <span class="n">arr_2</span><span class="o">=</span><span class="n">x2</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="greater_equal"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.greater_equal.html#nums.numpy.greater_equal">[docs]</a><span class="k">def</span> <span class="nf">greater_equal</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Return the truth value of (x1 &gt;= x2) element-wise.</span>

<span class="sd">    This docstring was copied from numpy.greater_equal.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1, x2 : BlockArray</span>
<span class="sd">        Input arrays.</span>
<span class="sd">        If ``x1.shape != x2.shape``, they must be broadcastable to a common</span>
<span class="sd">        shape (which becomes the shape of the output).</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : BlockArray of bool</span>
<span class="sd">        Output array, element-wise comparison of `x1` and `x2`.</span>
<span class="sd">        Typically of type bool, unless ``dtype=object`` is passed.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    greater, less, less_equal, equal, not_equal</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.greater_equal(nps.array([4, 2, 1]), nps.array([2, 2, 2])).get()  # doctest: +SKIP</span>
<span class="sd">    array([ True, True, False])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_bop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;greater_equal&quot;</span><span class="p">,</span>
        <span class="n">arr_1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span>
        <span class="n">arr_2</span><span class="o">=</span><span class="n">x2</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="heaviside"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.heaviside.html#nums.numpy.heaviside">[docs]</a><span class="k">def</span> <span class="nf">heaviside</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Compute the Heaviside step function.</span>

<span class="sd">    This docstring was copied from numpy.heaviside.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    The Heaviside step function is defined as::</span>

<span class="sd">                              0   if x1 &lt; 0</span>
<span class="sd">        heaviside(x1, x2) =  x2   if x1 == 0</span>
<span class="sd">                              1   if x1 &gt; 0</span>

<span class="sd">    where `x2` is often taken to be 0.5, but 0 and 1 are also sometimes used.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1 : BlockArray</span>
<span class="sd">        Input values.</span>
<span class="sd">    x2 : BlockArray</span>
<span class="sd">        The value of the function when x1 is 0.</span>
<span class="sd">        If ``x1.shape != x2.shape``, they must be broadcastable to a common</span>
<span class="sd">        shape (which becomes the shape of the output).</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : BlockArray</span>
<span class="sd">        The output array, element-wise Heaviside step function of `x1`.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. Wikipedia, &quot;Heaviside step function&quot;,</span>
<span class="sd">       https://en.wikipedia.org/wiki/Heaviside_step_function</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.heaviside(nps.array([-1.5, 0, 2.0]), nps.array(0.5)).get()  # doctest: +SKIP</span>
<span class="sd">    array([ 0. ,  0.5,  1. ])</span>
<span class="sd">    &gt;&gt;&gt; nps.heaviside(nps.array([-1.5, 0, 2.0]), nps.array(1)).get()  # doctest: +SKIP</span>
<span class="sd">    array([ 0.,  1.,  1.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_bop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;heaviside&quot;</span><span class="p">,</span>
        <span class="n">arr_1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span>
        <span class="n">arr_2</span><span class="o">=</span><span class="n">x2</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="hypot"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.hypot.html#nums.numpy.hypot">[docs]</a><span class="k">def</span> <span class="nf">hypot</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Given the &quot;legs&quot; of a right triangle, return its hypotenuse.</span>

<span class="sd">    This docstring was copied from numpy.hypot.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Equivalent to ``sqrt(x1**2 + x2**2)``, element-wise.  If `x1` or</span>
<span class="sd">    `x2` is scalar_like (i.e., unambiguously cast-able to a scalar type),</span>
<span class="sd">    it is broadcast for use with each element of the other argument.</span>
<span class="sd">    (See Examples)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1, x2 : BlockArray</span>
<span class="sd">        Leg of the triangle(s).</span>
<span class="sd">        If ``x1.shape != x2.shape``, they must be broadcastable to a common</span>
<span class="sd">        shape (which becomes the shape of the output).</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    z : BlockArray</span>
<span class="sd">        The hypotenuse of the triangle(s).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.hypot(3*nps.ones((3, 3)), 4*nps.ones((3, 3))).get()  # doctest: +SKIP</span>
<span class="sd">    array([[ 5.,  5.,  5.],</span>
<span class="sd">           [ 5.,  5.,  5.],</span>
<span class="sd">           [ 5.,  5.,  5.]])</span>

<span class="sd">    Example showing broadcast of scalar_like argument:</span>

<span class="sd">    &gt;&gt;&gt; nps.hypot(3*nps.ones((3, 3)), nps.array([4])).get()  # doctest: +SKIP</span>
<span class="sd">    array([[ 5.,  5.,  5.],</span>
<span class="sd">           [ 5.,  5.,  5.],</span>
<span class="sd">           [ 5.,  5.,  5.]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_bop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;hypot&quot;</span><span class="p">,</span>
        <span class="n">arr_1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span>
        <span class="n">arr_2</span><span class="o">=</span><span class="n">x2</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="lcm"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.lcm.html#nums.numpy.lcm">[docs]</a><span class="k">def</span> <span class="nf">lcm</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;This docstring was copied from numpy.lcm.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Returns the lowest common multiple of ``|x1|`` and ``|x2|``</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1, x2 : BlockArray, int</span>
<span class="sd">        Arrays of values.</span>
<span class="sd">        If ``x1.shape != x2.shape``, they must be broadcastable to a common</span>
<span class="sd">        shape (which becomes the shape of the output).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray</span>
<span class="sd">        The lowest common multiple of the absolute value of the inputs</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    gcd : The greatest common divisor</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.lcm(nps.array(12), nps.array(20)).get()  # doctest: +SKIP</span>
<span class="sd">    array(60)</span>
<span class="sd">    &gt;&gt;&gt; nps.lcm(nps.arange(6), nps.array(20)).get()  # doctest: +SKIP</span>
<span class="sd">    array([ 0, 20, 20, 60, 20, 20])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_bop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;lcm&quot;</span><span class="p">,</span>
        <span class="n">arr_1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span>
        <span class="n">arr_2</span><span class="o">=</span><span class="n">x2</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="ldexp"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.ldexp.html#nums.numpy.ldexp">[docs]</a><span class="k">def</span> <span class="nf">ldexp</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Returns x1 * 2**x2, element-wise.</span>

<span class="sd">    This docstring was copied from numpy.ldexp.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    The mantissas `x1` and twos exponents `x2` are used to construct</span>
<span class="sd">    floating point numbers ``x1 * 2**x2``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1 : BlockArray</span>
<span class="sd">        Array of multipliers.</span>
<span class="sd">    x2 : BlockArray, int</span>
<span class="sd">        Array of twos exponents.</span>
<span class="sd">        If ``x1.shape != x2.shape``, they must be broadcastable to a common</span>
<span class="sd">        shape (which becomes the shape of the output).</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray</span>
<span class="sd">        The result of ``x1 * 2**x2``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    frexp : Return (y1, y2) from ``x = y1 * 2**y2``, inverse to `ldexp`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Complex dtypes are not supported, they will raise a TypeError.</span>

<span class="sd">    `ldexp` is useful as the inverse of `frexp`, if used by itself it is</span>
<span class="sd">    more clear to simply use the expression ``x1 * 2**x2``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; x = nps.arange(6)  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; nps.ldexp(*nps.frexp(x)).get()  # doctest: +SKIP</span>
<span class="sd">    array([ 0.,  1.,  2.,  3.,  4.,  5.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_bop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;ldexp&quot;</span><span class="p">,</span>
        <span class="n">arr_1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span>
        <span class="n">arr_2</span><span class="o">=</span><span class="n">x2</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="left_shift"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.left_shift.html#nums.numpy.left_shift">[docs]</a><span class="k">def</span> <span class="nf">left_shift</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Shift the bits of an integer to the left.</span>

<span class="sd">    This docstring was copied from numpy.left_shift.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Bits are shifted to the left by appending `x2` 0s at the right of `x1`.</span>
<span class="sd">    Since the internal representation of numbers is in binary format, this</span>
<span class="sd">    operation is equivalent to multiplying `x1` by ``2**x2``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1 : BlockArray of integer type</span>
<span class="sd">        Input values.</span>
<span class="sd">    x2 : BlockArray of integer type</span>
<span class="sd">        Number of zeros to append to `x1`. Has to be non-negative.</span>
<span class="sd">        If ``x1.shape != x2.shape``, they must be broadcastable to a common</span>
<span class="sd">        shape (which becomes the shape of the output).</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : array of integer type</span>
<span class="sd">        Return `x1` with bits shifted `x2` times to the left.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    right_shift : Shift the bits of an integer to the right.</span>
<span class="sd">    binary_repr : Return the binary representation of the input number</span>
<span class="sd">        as a string.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.left_shift(nps.array(5), nps.array(2)).get()  # doctest: +SKIP</span>
<span class="sd">    array(20)</span>

<span class="sd">    Note that the dtype of the second argument may change the dtype of the</span>
<span class="sd">    result and can lead to unexpected results in some cases (see</span>
<span class="sd">    :ref:`Casting Rules &lt;ufuncs.casting&gt;`):</span>

<span class="sd">    &gt;&gt;&gt; a = nps.left_shift(nps.array(255, dtype=nps.uint8),</span>
<span class="sd">    ...     nps.array(1)) # Expect 254  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; print(a, type(a)) # Unexpected result due to upcasting  # doctest: +SKIP</span>
<span class="sd">    510 &lt;class &#39;nums.core.array.blockarray.BlockArray&#39;&gt;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_bop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;left_shift&quot;</span><span class="p">,</span>
        <span class="n">arr_1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span>
        <span class="n">arr_2</span><span class="o">=</span><span class="n">x2</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="less"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.less.html#nums.numpy.less">[docs]</a><span class="k">def</span> <span class="nf">less</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Return the truth value of (x1 &lt; x2) element-wise.</span>

<span class="sd">    This docstring was copied from numpy.less.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1, x2 : BlockArray</span>
<span class="sd">        Input arrays.</span>
<span class="sd">        If ``x1.shape != x2.shape``, they must be broadcastable to a common</span>
<span class="sd">        shape (which becomes the shape of the output).</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : BlockArray</span>
<span class="sd">        Output array, element-wise comparison of `x1` and `x2`.</span>
<span class="sd">        Typically of type bool, unless ``dtype=object`` is passed.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    greater, less_equal, greater_equal, equal, not_equal</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.less(nps.array([1, 2]), nps.array([2, 2])).get()  # doctest: +SKIP</span>
<span class="sd">    array([ True, False])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_bop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;less&quot;</span><span class="p">,</span>
        <span class="n">arr_1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span>
        <span class="n">arr_2</span><span class="o">=</span><span class="n">x2</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="less_equal"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.less_equal.html#nums.numpy.less_equal">[docs]</a><span class="k">def</span> <span class="nf">less_equal</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Return the truth value of (x1 =&lt; x2) element-wise.</span>

<span class="sd">    This docstring was copied from numpy.less_equal.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1, x2 : BlockArray</span>
<span class="sd">        Input arrays.</span>
<span class="sd">        If ``x1.shape != x2.shape``, they must be broadcastable to a common</span>
<span class="sd">        shape (which becomes the shape of the output).</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : BlockArray</span>
<span class="sd">        Output array, element-wise comparison of `x1` and `x2`.</span>
<span class="sd">        Typically of type bool, unless ``dtype=object`` is passed.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    greater, less, greater_equal, equal, not_equal</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.less_equal(nps.array([4, 2, 1]), nps.array([2, 2, 2])).get()  # doctest: +SKIP</span>
<span class="sd">    array([False,  True,  True])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_bop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;less_equal&quot;</span><span class="p">,</span>
        <span class="n">arr_1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span>
        <span class="n">arr_2</span><span class="o">=</span><span class="n">x2</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="logaddexp"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.logaddexp.html#nums.numpy.logaddexp">[docs]</a><span class="k">def</span> <span class="nf">logaddexp</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Logarithm of the sum of exponentiations of the inputs.</span>

<span class="sd">    This docstring was copied from numpy.logaddexp.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Calculates ``log(exp(x1) + exp(x2))``. This function is useful in</span>
<span class="sd">    statistics where the calculated probabilities of events may be so small</span>
<span class="sd">    as to exceed the range of normal floating point numbers.  In such cases</span>
<span class="sd">    the logarithm of the calculated probability is stored. This function</span>
<span class="sd">    allows adding probabilities stored in such a fashion.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1, x2 : BlockArray</span>
<span class="sd">        Input values.</span>
<span class="sd">        If ``x1.shape != x2.shape``, they must be broadcastable to a common</span>
<span class="sd">        shape (which becomes the shape of the output).</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : BlockArray</span>
<span class="sd">        Logarithm of ``exp(x1) + exp(x2)``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    logaddexp2: Logarithm of the sum of exponentiations of inputs in base 2.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; prob1 = nps.log(nps.array(1e-50))  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; prob2 = nps.log(nps.array(2.5e-50))  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; prob12 = nps.logaddexp(prob1, prob2)  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; prob12.get()  # doctest: +SKIP</span>
<span class="sd">    array(-113.87649168)</span>
<span class="sd">    &gt;&gt;&gt; nps.exp(prob12).get()  # doctest: +SKIP</span>
<span class="sd">    array(3.5e-50)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_bop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;logaddexp&quot;</span><span class="p">,</span>
        <span class="n">arr_1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span>
        <span class="n">arr_2</span><span class="o">=</span><span class="n">x2</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="logaddexp2"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.logaddexp2.html#nums.numpy.logaddexp2">[docs]</a><span class="k">def</span> <span class="nf">logaddexp2</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Logarithm of the sum of exponentiations of the inputs in base-2.</span>

<span class="sd">    This docstring was copied from numpy.logaddexp2.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Calculates ``log2(2**x1 + 2**x2)``. This function is useful in machine</span>
<span class="sd">    learning when the calculated probabilities of events may be so small as</span>
<span class="sd">    to exceed the range of normal floating point numbers.  In such cases</span>
<span class="sd">    the base-2 logarithm of the calculated probability can be used instead.</span>
<span class="sd">    This function allows adding probabilities stored in such a fashion.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1, x2 : BlockArray</span>
<span class="sd">        Input values.</span>
<span class="sd">        If ``x1.shape != x2.shape``, they must be broadcastable to a common</span>
<span class="sd">        shape (which becomes the shape of the output).</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : BlockArray</span>
<span class="sd">        Base-2 logarithm of ``2**x1 + 2**x2``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    logaddexp: Logarithm of the sum of exponentiations of the inputs.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>
<span class="sd">    &gt;&gt;&gt; prob1 = nps.log(nps.array(1e-50))  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; prob2 = nps.log(nps.array(2.5e-50))  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; prob12 = nps.logaddexp2(prob1, prob2)  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; prob1.get(), prob2.get(), prob12.get()  # doctest: +SKIP</span>
<span class="sd">    (array(-115.12925465), array(-114.21296392), array(-113.59955523))</span>
<span class="sd">    &gt;&gt;&gt; 2**prob12  # doctest: +SKIP</span>
<span class="sd">    array(6.35515844e-35)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_bop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;logaddexp2&quot;</span><span class="p">,</span>
        <span class="n">arr_1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span>
        <span class="n">arr_2</span><span class="o">=</span><span class="n">x2</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="logical_and"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.logical_and.html#nums.numpy.logical_and">[docs]</a><span class="k">def</span> <span class="nf">logical_and</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Compute the truth value of x1 AND x2 element-wise.</span>

<span class="sd">    This docstring was copied from numpy.logical_and.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1, x2 : BlockArray</span>
<span class="sd">        Input arrays.</span>
<span class="sd">        If ``x1.shape != x2.shape``, they must be broadcastable to a common</span>
<span class="sd">        shape (which becomes the shape of the output).</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray</span>
<span class="sd">        Boolean result of the logical AND operation applied to the elements</span>
<span class="sd">        of `x1` and `x2`; the shape is determined by broadcasting.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    logical_or, logical_not, logical_xor</span>
<span class="sd">    bitwise_and</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.logical_and(nps.array(True), nps.array(False)).get()  # doctest: +SKIP</span>
<span class="sd">    array(False)</span>
<span class="sd">    &gt;&gt;&gt; nps.logical_and(nps.array([True, False]), nps.array([False, False])).get()  # doctest: +SKIP</span>
<span class="sd">    array([False, False])</span>

<span class="sd">    &gt;&gt;&gt; x = nps.arange(5)  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; nps.logical_and(x&gt;1, x&lt;4).get()  # doctest: +SKIP</span>
<span class="sd">    array([False, False,  True,  True, False])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_bop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;logical_and&quot;</span><span class="p">,</span>
        <span class="n">arr_1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span>
        <span class="n">arr_2</span><span class="o">=</span><span class="n">x2</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="logical_or"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.logical_or.html#nums.numpy.logical_or">[docs]</a><span class="k">def</span> <span class="nf">logical_or</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Compute the truth value of x1 OR x2 element-wise.</span>

<span class="sd">    This docstring was copied from numpy.logical_or.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1, x2 : BlockArray</span>
<span class="sd">        Logical OR is applied to the elements of `x1` and `x2`.</span>
<span class="sd">        If ``x1.shape != x2.shape``, they must be broadcastable to a common</span>
<span class="sd">        shape (which becomes the shape of the output).</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray</span>
<span class="sd">        Boolean result of the logical OR operation applied to the elements</span>
<span class="sd">        of `x1` and `x2`; the shape is determined by broadcasting.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    logical_and, logical_not, logical_xor</span>
<span class="sd">    bitwise_or</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.logical_or(nps.array(True), nps.array(False)).get()  # doctest: +SKIP</span>
<span class="sd">    array(True)</span>
<span class="sd">    &gt;&gt;&gt; nps.logical_or(nps.array([True, False]), nps.array([False, False])).get()  # doctest: +SKIP</span>
<span class="sd">    array([ True, False])</span>

<span class="sd">    &gt;&gt;&gt; x = nps.arange(5)  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; nps.logical_or(x &lt; 1, x &gt; 3).get()  # doctest: +SKIP</span>
<span class="sd">    array([ True, False, False, False,  True])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_bop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;logical_or&quot;</span><span class="p">,</span>
        <span class="n">arr_1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span>
        <span class="n">arr_2</span><span class="o">=</span><span class="n">x2</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="logical_xor"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.logical_xor.html#nums.numpy.logical_xor">[docs]</a><span class="k">def</span> <span class="nf">logical_xor</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Compute the truth value of x1 XOR x2, element-wise.</span>

<span class="sd">    This docstring was copied from numpy.logical_xor.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1, x2 : BlockArray</span>
<span class="sd">        Logical XOR is applied to the elements of `x1` and `x2`.</span>
<span class="sd">        If ``x1.shape != x2.shape``, they must be broadcastable to a common</span>
<span class="sd">        shape (which becomes the shape of the output).</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray of bool</span>
<span class="sd">        Boolean result of the logical XOR operation applied to the elements</span>
<span class="sd">        of `x1` and `x2`; the shape is determined by broadcasting.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    logical_and, logical_or, logical_not, bitwise_xor</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.logical_xor(nps.array(True), nps.array(False)).get()  # doctest: +SKIP</span>
<span class="sd">    array(True)</span>
<span class="sd">    &gt;&gt;&gt; nps.logical_xor(nps.array([True, True, False, False]),</span>
<span class="sd">    ...     nps.array([True, False, True, False])).get()  # doctest: +SKIP</span>
<span class="sd">    array([False,  True,  True, False])</span>

<span class="sd">    &gt;&gt;&gt; x = nps.arange(5)  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; nps.logical_xor(x &lt; 1, x &gt; 3).get()  # doctest: +SKIP</span>
<span class="sd">    array([ True, False, False, False,  True])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_bop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;logical_xor&quot;</span><span class="p">,</span>
        <span class="n">arr_1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span>
        <span class="n">arr_2</span><span class="o">=</span><span class="n">x2</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="maximum"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.maximum.html#nums.numpy.maximum">[docs]</a><span class="k">def</span> <span class="nf">maximum</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Element-wise maximum of array elements.</span>

<span class="sd">    This docstring was copied from numpy.maximum.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Compare two arrays and returns a new array containing the element-wise</span>
<span class="sd">    maxima. If one of the elements being compared is a NaN, then that</span>
<span class="sd">    element is returned. If both elements are NaNs then the first is</span>
<span class="sd">    returned. The latter distinction is important for complex NaNs, which</span>
<span class="sd">    are defined as at least one of the real or imaginary parts being a NaN.</span>
<span class="sd">    The net effect is that NaNs are propagated.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1, x2 : BlockArray</span>
<span class="sd">        The arrays holding the elements to be compared.</span>
<span class="sd">        If ``x1.shape != x2.shape``, they must be broadcastable to a common</span>
<span class="sd">        shape (which becomes the shape of the output).</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray</span>
<span class="sd">        The maximum of `x1` and `x2`, element-wise.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    minimum :</span>
<span class="sd">        Element-wise minimum of two arrays, propagates NaNs.</span>
<span class="sd">    fmax :</span>
<span class="sd">        Element-wise maximum of two arrays, ignores NaNs.</span>
<span class="sd">    amax :</span>
<span class="sd">        The maximum value of an array along a given axis, propagates NaNs.</span>
<span class="sd">    nanmax :</span>
<span class="sd">        The maximum value of an array along a given axis, ignores NaNs.</span>

<span class="sd">    fmin, amin, nanmin</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The maximum is equivalent to ``nps.where(x1 &gt;= x2, x1, x2).get()`` when</span>
<span class="sd">    neither x1 nor x2 are nans, but it is faster and does proper</span>
<span class="sd">    broadcasting.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.maximum(nps.array([2, 3, 4]), nps.array([1, 5, 2])).get()  # doctest: +SKIP</span>
<span class="sd">    array([2, 5, 4])</span>

<span class="sd">    &gt;&gt;&gt; nps.maximum(nps.eye(2), nps.array([0.5, 2])).get() # broadcasting  # doctest: +SKIP</span>
<span class="sd">    array([[ 1. ,  2. ],</span>
<span class="sd">           [ 0.5,  2. ]])</span>

<span class="sd">    &gt;&gt;&gt; nps.maximum(nps.array([nps.nan, 0, nps.nan]),</span>
<span class="sd">    ...     nps.array([0, nps.nan, nps.nan])).get()  # doctest: +SKIP</span>
<span class="sd">    array([nan, nan, nan])</span>
<span class="sd">    &gt;&gt;&gt; nps.maximum(nps.array(nps.Inf), nps.array(1)).get()  # doctest: +SKIP</span>
<span class="sd">    arrray(inf)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_bop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;maximum&quot;</span><span class="p">,</span>
        <span class="n">arr_1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span>
        <span class="n">arr_2</span><span class="o">=</span><span class="n">x2</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="minimum"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.minimum.html#nums.numpy.minimum">[docs]</a><span class="k">def</span> <span class="nf">minimum</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Element-wise minimum of array elements.</span>

<span class="sd">    This docstring was copied from numpy.minimum.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Compare two arrays and returns a new array containing the element-wise</span>
<span class="sd">    minima. If one of the elements being compared is a NaN, then that</span>
<span class="sd">    element is returned. If both elements are NaNs then the first is</span>
<span class="sd">    returned. The latter distinction is important for complex NaNs, which</span>
<span class="sd">    are defined as at least one of the real or imaginary parts being a NaN.</span>
<span class="sd">    The net effect is that NaNs are propagated.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1, x2 : BlockArray</span>
<span class="sd">        The arrays holding the elements to be compared.</span>
<span class="sd">        If ``x1.shape != x2.shape``, they must be broadcastable to a common</span>
<span class="sd">        shape (which becomes the shape of the output).</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray</span>
<span class="sd">        The minimum of `x1` and `x2`, element-wise.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    maximum :</span>
<span class="sd">        Element-wise maximum of two arrays, propagates NaNs.</span>
<span class="sd">    fmin :</span>
<span class="sd">        Element-wise minimum of two arrays, ignores NaNs.</span>
<span class="sd">    amin :</span>
<span class="sd">        The minimum value of an array along a given axis, propagates NaNs.</span>
<span class="sd">    nanmin :</span>
<span class="sd">        The minimum value of an array along a given axis, ignores NaNs.</span>

<span class="sd">    fmax, amax, nanmax</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The minimum is equivalent to ``nps.where(x1 &lt;= x2, x1, x2).get()`` when</span>
<span class="sd">    neither x1 nor x2 are NaNs, but it is faster and does proper</span>
<span class="sd">    broadcasting.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.minimum(nps.array([2, 3, 4]), nps.array([1, 5, 2])).get()  # doctest: +SKIP</span>
<span class="sd">    array([1, 3, 2])</span>

<span class="sd">    &gt;&gt;&gt; nps.minimum(nps.eye(2), nps.array([0.5, 2])).get() # broadcasting  # doctest: +SKIP</span>
<span class="sd">    array([[ 0.5,  0. ],</span>
<span class="sd">           [ 0. ,  1. ]])</span>

<span class="sd">    &gt;&gt;&gt; nps.minimum(nps.array([nps.nan, 0, nps.nan]),</span>
<span class="sd">    ...     nps.array([0, nps.nan, nps.nan])).get()  # doctest: +SKIP</span>
<span class="sd">    array([nan, nan, nan])</span>
<span class="sd">    &gt;&gt;&gt; nps.minimum(nps.array(-nps.Inf), nps.array(1)).get()  # doctest: +SKIP</span>
<span class="sd">    array(-inf)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_bop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;minimum&quot;</span><span class="p">,</span>
        <span class="n">arr_1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span>
        <span class="n">arr_2</span><span class="o">=</span><span class="n">x2</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="mod"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.mod.html#nums.numpy.mod">[docs]</a><span class="k">def</span> <span class="nf">mod</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Return element-wise remainder of division.</span>

<span class="sd">    This docstring was copied from numpy.mod.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Computes the remainder complementary to the `floor_divide` function.  It is</span>
<span class="sd">    equivalent to the Python modulus operator``x1 % x2`` and has the same sign</span>
<span class="sd">    as the divisor `x2`. The MATLAB function equivalent to ``nps.remainder``</span>
<span class="sd">    is ``mod``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1 : BlockArray</span>
<span class="sd">        Dividend array.</span>
<span class="sd">    x2 : BlockArray</span>
<span class="sd">        Divisor array.</span>
<span class="sd">        If ``x1.shape != x2.shape``, they must be broadcastable to a common</span>
<span class="sd">        shape (which becomes the shape of the output).</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray</span>
<span class="sd">        The element-wise remainder of the quotient ``floor_divide(x1, x2)``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    floor_divide : Equivalent of Python ``//`` operator.</span>
<span class="sd">    divmod : Simultaneous floor division and remainder.</span>
<span class="sd">    fmod : Equivalent of the MATLAB ``rem`` function.</span>
<span class="sd">    divide, floor</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Returns 0 when `x2` is 0 and both `x1` and `x2` are (arrays of)</span>
<span class="sd">    integers.</span>
<span class="sd">    ``mod`` is an alias of ``remainder``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.remainder(nps.array([4, 7]), nps.array([2, 3])).get()  # doctest: +SKIP</span>
<span class="sd">    array([0, 1])</span>
<span class="sd">    &gt;&gt;&gt; nps.remainder(nps.arange(7), nps.array(5)).get()  # doctest: +SKIP</span>
<span class="sd">    array([0, 1, 2, 3, 4, 0, 1])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_bop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;mod&quot;</span><span class="p">,</span>
        <span class="n">arr_1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span>
        <span class="n">arr_2</span><span class="o">=</span><span class="n">x2</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="multiply"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.multiply.html#nums.numpy.multiply">[docs]</a><span class="k">def</span> <span class="nf">multiply</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Multiply arguments element-wise.</span>

<span class="sd">    This docstring was copied from numpy.multiply.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1, x2 : BlockArray</span>
<span class="sd">        Input arrays to be multiplied.</span>
<span class="sd">        If ``x1.shape != x2.shape``, they must be broadcastable to a common</span>
<span class="sd">        shape (which becomes the shape of the output).</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray</span>
<span class="sd">        The product of `x1` and `x2`, element-wise.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Equivalent to `x1` * `x2` in terms of array broadcasting.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.multiply(nps.array(2.0), nps.array(4.0)).get()  # doctest: +SKIP</span>
<span class="sd">    array(8.)</span>

<span class="sd">    &gt;&gt;&gt; x1 = nps.arange(9.0).reshape((3, 3))  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; x2 = nps.arange(3.0)  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; nps.multiply(x1, x2).get()  # doctest: +SKIP</span>
<span class="sd">    array([[  0.,   1.,   4.],</span>
<span class="sd">           [  0.,   4.,  10.],</span>
<span class="sd">           [  0.,   7.,  16.]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_bop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;multiply&quot;</span><span class="p">,</span>
        <span class="n">arr_1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span>
        <span class="n">arr_2</span><span class="o">=</span><span class="n">x2</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="nextafter"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.nextafter.html#nums.numpy.nextafter">[docs]</a><span class="k">def</span> <span class="nf">nextafter</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Return the next floating-point value after x1 towards x2, element-wise.</span>

<span class="sd">    This docstring was copied from numpy.nextafter.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1 : BlockArray</span>
<span class="sd">        Values to find the next representable value of.</span>
<span class="sd">    x2 : BlockArray</span>
<span class="sd">        The direction where to look for the next representable value of `x1`.</span>
<span class="sd">        If ``x1.shape != x2.shape``, they must be broadcastable to a common</span>
<span class="sd">        shape (which becomes the shape of the output).</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : BlockArray</span>
<span class="sd">        The next representable values of `x1` in the direction of `x2`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_bop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;nextafter&quot;</span><span class="p">,</span>
        <span class="n">arr_1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span>
        <span class="n">arr_2</span><span class="o">=</span><span class="n">x2</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="not_equal"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.not_equal.html#nums.numpy.not_equal">[docs]</a><span class="k">def</span> <span class="nf">not_equal</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;This docstring was copied from numpy.not_equal.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Return (x1 != x2) element-wise.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1, x2 : BlockArray</span>
<span class="sd">        Input arrays.</span>
<span class="sd">        If ``x1.shape != x2.shape``, they must be broadcastable to a common</span>
<span class="sd">        shape (which becomes the shape of the output).</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : BlockArray</span>
<span class="sd">        Output array, element-wise comparison of `x1` and `x2`.</span>
<span class="sd">        Typically of type bool, unless ``dtype=object`` is passed.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    equal, greater, greater_equal, less, less_equal</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.not_equal(nps.array([1.,2.]), nps.array([1., 3.])).get()  # doctest: +SKIP</span>
<span class="sd">    array([False,  True])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_bop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;not_equal&quot;</span><span class="p">,</span>
        <span class="n">arr_1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span>
        <span class="n">arr_2</span><span class="o">=</span><span class="n">x2</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="power"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.power.html#nums.numpy.power">[docs]</a><span class="k">def</span> <span class="nf">power</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;First array elements raised to powers from second array, element-wise.</span>

<span class="sd">    This docstring was copied from numpy.power.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Raise each base in `x1` to the positionally-corresponding power in</span>
<span class="sd">    `x2`.  `x1` and `x2` must be broadcastable to the same shape. Note that an</span>
<span class="sd">    integer type raised to a negative integer power will raise a ValueError.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1 : BlockArray</span>
<span class="sd">        The bases.</span>
<span class="sd">    x2 : BlockArray</span>
<span class="sd">        The exponents.</span>
<span class="sd">        If ``x1.shape != x2.shape``, they must be broadcastable to a common</span>
<span class="sd">        shape (which becomes the shape of the output).</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray</span>
<span class="sd">        The bases in `x1` raised to the exponents in `x2`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    float_power : power function that promotes integers to float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_bop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;power&quot;</span><span class="p">,</span>
        <span class="n">arr_1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span>
        <span class="n">arr_2</span><span class="o">=</span><span class="n">x2</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="remainder"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.remainder.html#nums.numpy.remainder">[docs]</a><span class="k">def</span> <span class="nf">remainder</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Return element-wise remainder of division.</span>

<span class="sd">    This docstring was copied from numpy.remainder.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Computes the remainder complementary to the `floor_divide` function.  It is</span>
<span class="sd">    equivalent to the Python modulus operator``x1 % x2`` and has the same sign</span>
<span class="sd">    as the divisor `x2`. The MATLAB function equivalent to ``nps.remainder``</span>
<span class="sd">    is ``mod``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1 : BlockArray</span>
<span class="sd">        Dividend array.</span>
<span class="sd">    x2 : BlockArray</span>
<span class="sd">        Divisor array.</span>
<span class="sd">        If ``x1.shape != x2.shape``, they must be broadcastable to a common</span>
<span class="sd">        shape (which becomes the shape of the output).</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray</span>
<span class="sd">        The element-wise remainder of the quotient ``floor_divide(x1, x2)``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    floor_divide : Equivalent of Python ``//`` operator.</span>
<span class="sd">    divmod : Simultaneous floor division and remainder.</span>
<span class="sd">    fmod : Equivalent of the MATLAB ``rem`` function.</span>
<span class="sd">    divide, floor</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Returns 0 when `x2` is 0 and both `x1` and `x2` are (arrays of)</span>
<span class="sd">    integers.</span>
<span class="sd">    ``mod`` is an alias of ``remainder``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.remainder(nps.array([4, 7]), nps.array([2, 3])).get()  # doctest: +SKIP</span>
<span class="sd">    array([0, 1])</span>
<span class="sd">    &gt;&gt;&gt; nps.remainder(nps.arange(7), nps.array(5)).get()  # doctest: +SKIP</span>
<span class="sd">    array([0, 1, 2, 3, 4, 0, 1])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_bop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;remainder&quot;</span><span class="p">,</span>
        <span class="n">arr_1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span>
        <span class="n">arr_2</span><span class="o">=</span><span class="n">x2</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="right_shift"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.right_shift.html#nums.numpy.right_shift">[docs]</a><span class="k">def</span> <span class="nf">right_shift</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Shift the bits of an integer to the right.</span>

<span class="sd">    This docstring was copied from numpy.right_shift.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Bits are shifted to the right `x2`.  Because the internal</span>
<span class="sd">    representation of numbers is in binary format, this operation is</span>
<span class="sd">    equivalent to dividing `x1` by ``2**x2``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1 : BlockArray, int</span>
<span class="sd">        Input values.</span>
<span class="sd">    x2 : BlockArray, int</span>
<span class="sd">        Number of bits to remove at the right of `x1`.</span>
<span class="sd">        If ``x1.shape != x2.shape``, they must be broadcastable to a common</span>
<span class="sd">        shape (which becomes the shape of the output).</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : BlockArray</span>
<span class="sd">        Return `x1` with bits shifted `x2` times to the right.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    left_shift : Shift the bits of an integer to the left.</span>
<span class="sd">    binary_repr : Return the binary representation of the input number</span>
<span class="sd">        as a string.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.right_shift(nps.array(10), nps.array(1)).get()  # doctest: +SKIP</span>
<span class="sd">    5</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_bop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;right_shift&quot;</span><span class="p">,</span>
        <span class="n">arr_1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span>
        <span class="n">arr_2</span><span class="o">=</span><span class="n">x2</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="subtract"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.subtract.html#nums.numpy.subtract">[docs]</a><span class="k">def</span> <span class="nf">subtract</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Subtract arguments, element-wise.</span>

<span class="sd">    This docstring was copied from numpy.subtract.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1, x2 : BlockArray</span>
<span class="sd">        The arrays to be subtracted from each other.</span>
<span class="sd">        If ``x1.shape != x2.shape``, they must be broadcastable to a common</span>
<span class="sd">        shape (which becomes the shape of the output).</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : BlockArray</span>
<span class="sd">        The difference of `x1` and `x2`, element-wise.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Equivalent to ``x1 - x2`` in terms of array broadcasting.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.subtract(nps.array(1.0), nps.array(4.0)).get()  # doctest: +SKIP</span>
<span class="sd">    array(-3.)</span>

<span class="sd">    &gt;&gt;&gt; x1 = nps.arange(9.0).reshape((3, 3))  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; x2 = nps.arange(3.0)  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; nps.subtract(x1, x2).get()  # doctest: +SKIP</span>
<span class="sd">    array([[ 0.,  0.,  0.],</span>
<span class="sd">           [ 3.,  3.,  3.],</span>
<span class="sd">           [ 6.,  6.,  6.]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_bop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;subtract&quot;</span><span class="p">,</span>
        <span class="n">arr_1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span>
        <span class="n">arr_2</span><span class="o">=</span><span class="n">x2</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="true_divide"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.true_divide.html#nums.numpy.true_divide">[docs]</a><span class="k">def</span> <span class="nf">true_divide</span><span class="p">(</span>
    <span class="n">x1</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="n">BlockArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockArray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Returns a true division of the inputs, element-wise.</span>

<span class="sd">    This docstring was copied from numpy.true_divide.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Instead of the Python traditional &#39;floor division&#39;, this returns a true</span>
<span class="sd">    division.  True division adjusts the output type to present the best</span>
<span class="sd">    answer, regardless of input types.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1 : BlockArray</span>
<span class="sd">        Dividend array.</span>
<span class="sd">    x2 : BlockArray</span>
<span class="sd">        Divisor array.</span>
<span class="sd">        If ``x1.shape != x2.shape``, they must be broadcastable to a common</span>
<span class="sd">        shape (which becomes the shape of the output).</span>
<span class="sd">    out : BlockArray, None, or optional</span>
<span class="sd">        A location into which the result is stored. If provided, it must have</span>
<span class="sd">        a shape that the inputs broadcast to. If not provided or None,</span>
<span class="sd">        a freshly-allocated array is returned. A tuple (possible only as a</span>
<span class="sd">        keyword argument) must have length equal to the number of outputs.</span>
<span class="sd">    where : BlockArray, optional</span>
<span class="sd">        This condition is broadcast over the input. At locations where the</span>
<span class="sd">        condition is True, the `out` array will be set to the ufunc result.</span>
<span class="sd">        Elsewhere, the `out` array will retain its original value.</span>
<span class="sd">        Note that if an uninitialized `out` array is created via the default</span>
<span class="sd">        ``out=None``, locations within it where the condition is False will</span>
<span class="sd">        remain uninitialized.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        For other keyword-only arguments, see the</span>
<span class="sd">        :ref:`ufunc docs &lt;ufuncs.kwargs&gt;`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : BlockArray</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    In Python, ``//`` is the floor division operator and ``/`` the</span>
<span class="sd">    true division operator.  The ``true_divide(x1, x2)`` function is</span>
<span class="sd">    equivalent to true division in Python.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; x = nps.arange(5)  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; nps.true_divide(x, nps.array(4)).get()  # doctest: +SKIP</span>
<span class="sd">    array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])</span>

<span class="sd">    &gt;&gt;&gt; (x/4).get()  # doctest: +SKIP</span>
<span class="sd">    array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">map_bop</span><span class="p">(</span>
        <span class="n">op_name</span><span class="o">=</span><span class="s2">&quot;true_divide&quot;</span><span class="p">,</span>
        <span class="n">arr_1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span>
        <span class="n">arr_2</span><span class="o">=</span><span class="n">x2</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="o">=</span><span class="n">numpy_utils</span><span class="o">.</span><span class="n">ufunc_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">),</span>
    <span class="p">)</span></div>
</pre></div>

              </div>
              
              
              <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
              
          </main>
          

      </div>
    </div>
  
    <script src="../../../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>
  <footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2022, The NumS Team.<br>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.5.4.<br>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>