
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>nums.numpy.api.nan &#8212; NumS  documentation</title>
    
    <link href="../../../../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../../../../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
  
    
    <link rel="stylesheet"
      href="../../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
    <link rel="preload" as="font" type="font/woff2" crossorigin
      href="../../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
    <link rel="preload" as="font" type="font/woff2" crossorigin
      href="../../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">
  
    
      
  
    
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/styles/pydata-sphinx-theme.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/css/nums.css" />
    
    <link rel="preload" as="script" href="../../../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">
  
    <script id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    
      
      <link rel="icon" sizes="16x16" href="../../../../_static/icon.svg">
      
    
      
      <link rel="icon" sizes="32x32" href="../../../../_static/icon.svg">
      
    
      
      <link rel="apple-touch-icon" sizes="180x180" href="../../../../_static/apple-touch-icon-180x180.png">
      
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    

<a class="navbar-brand" href="../../../../index.html">
  <img src="../../../../_static/logo.svg" class="logo" alt="logo">
</a>


    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../get_started/index.html">
  Get Started
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../user_guide/index.html">
  User Guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../reference/index.html">
  API Reference
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../../development/index.html">
  Development
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/nums-project/nums" rel="noopener" target="_blank" title="GitHub"><span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://twitter.com/nums_project" rel="noopener" target="_blank" title="Twitter"><span><i class="fab fa-twitter-square"></i></span>
            <label class="sr-only">Twitter</label></a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar">
              <div class="sidebar-start-items"><form class="bd-search d-flex align-items-center" action="../../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
              </div>
              <div class="sidebar-end-items">
              </div>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <h1>Source code for nums.numpy.api.nan</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (C) 2020 NumS Development Team.</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>

<span class="c1"># pylint: disable = redefined-builtin, too-many-lines, anomalous-backslash-in-string, unused-wildcard-import, wildcard-import</span>

<span class="kn">from</span> <span class="nn">nums.core.application_manager</span> <span class="kn">import</span> <span class="n">instance</span> <span class="k">as</span> <span class="n">_instance</span>
<span class="kn">from</span> <span class="nn">nums.core.array.blockarray</span> <span class="kn">import</span> <span class="n">BlockArray</span>

<span class="c1">############################################</span>
<span class="c1"># NaN Ops</span>
<span class="c1">############################################</span>


<div class="viewcode-block" id="nanmax"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.nanmax.html#nums.numpy.api.nan.nanmax">[docs]</a><span class="k">def</span> <span class="nf">nanmax</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the maximum of an array or maximum along an axis, ignoring any</span>
<span class="sd">    NaNs.  When all-NaN slices are encountered a ``RuntimeWarning`` is</span>
<span class="sd">    raised and NaN is returned for that slice.</span>

<span class="sd">    This docstring was copied from numpy.nanmax.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : BlockArray</span>
<span class="sd">        Array containing numbers whose maximum is desired. If `a` is not an</span>
<span class="sd">        array, a conversion is attempted.</span>
<span class="sd">    axis : {int, tuple of int, None}, optional</span>
<span class="sd">        Axis or axes along which the maximum is computed. The default is to compute</span>
<span class="sd">        the maximum of the flattened array.</span>
<span class="sd">    out : BlockArray, optional</span>
<span class="sd">        Alternate output array in which to place the result.  The default</span>
<span class="sd">        is ``None``; if provided, it must have the same shape as the</span>
<span class="sd">        expected output, but the type will be cast if necessary.</span>
<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left</span>
<span class="sd">        in the result as dimensions with size one. With this option,</span>
<span class="sd">        the result will broadcast correctly against the original `a`.</span>
<span class="sd">        If the value is anything but the default, then</span>
<span class="sd">        `keepdims` will be passed through to the `max` method</span>
<span class="sd">        of sub-classes of `BlockArray`.  If the sub-classes methods</span>
<span class="sd">        does not implement `keepdims` any exceptions will be raised.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    nanmax : BlockArray</span>
<span class="sd">        An array with the same shape as `a`, with the specified axis removed.</span>
<span class="sd">        If `a` is a 0-d array, or if axis is None, an BlockArray scalar is</span>
<span class="sd">        returned.  The same dtype as `a` is returned.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    nanmin :</span>
<span class="sd">        The minimum value of an array along a given axis, ignoring any NaNs.</span>
<span class="sd">    amax :</span>
<span class="sd">        The maximum value of an array along a given axis, propagating any NaNs.</span>
<span class="sd">    fmax :</span>
<span class="sd">        Element-wise maximum of two arrays, ignoring any NaNs.</span>
<span class="sd">    maximum :</span>
<span class="sd">        Element-wise maximum of two arrays, propagating any NaNs.</span>
<span class="sd">    isnan :</span>
<span class="sd">        Shows which elements are Not a Number (NaN).</span>
<span class="sd">    isfinite:</span>
<span class="sd">        Shows which elements are neither NaN nor infinity.</span>

<span class="sd">    amin, fmin, minimum</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic</span>
<span class="sd">    (IEEE 754). This means that Not a Number is not equivalent to infinity.</span>
<span class="sd">    Positive infinity is treated as a very large number and negative</span>
<span class="sd">    infinity is treated as a very small (i.e. negative) number.</span>

<span class="sd">    If the input has a integer type the function is equivalent to nps.max.</span>

<span class="sd">    &#39;out&#39; is currently not supported.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; a = nps.array([[1, 2], [3, nps.nan]])  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; nps.nanmax(a).get()  # doctest: +SKIP</span>
<span class="sd">    array(3.)</span>
<span class="sd">    &gt;&gt;&gt; nps.nanmax(a, axis=0).get()  # doctest: +SKIP</span>
<span class="sd">    array([3.,  2.])</span>
<span class="sd">    &gt;&gt;&gt; nps.nanmax(a, axis=1).get()  # doctest: +SKIP</span>
<span class="sd">    array([2.,  3.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;&#39;out&#39; is currently not supported.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="s2">&quot;nanmax&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span></div>


<div class="viewcode-block" id="nanmean"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.nanmean.html#nums.numpy.api.nan.nanmean">[docs]</a><span class="k">def</span> <span class="nf">nanmean</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the arithmetic mean along the specified axis, ignoring NaNs.</span>

<span class="sd">    This docstring was copied from numpy.nanmean.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Returns the average of the array elements.  The average is taken over</span>
<span class="sd">    the flattened array by default, otherwise over the specified axis.</span>
<span class="sd">    `float` intermediate and return values are used for integer inputs.</span>

<span class="sd">    For all-NaN slices, NaN is returned and a `RuntimeWarning` is raised.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : BlockArray</span>
<span class="sd">        Array containing numbers whose mean is desired. If `a` is not an</span>
<span class="sd">        array, a conversion is attempted.</span>
<span class="sd">    axis : {int, tuple of int, None}, optional</span>
<span class="sd">        Axis or axes along which the means are computed. The default is to compute</span>
<span class="sd">        the mean of the flattened array.</span>
<span class="sd">    dtype : data-type, optional</span>
<span class="sd">        Type to use in computing the mean.  For integer inputs, the default</span>
<span class="sd">        is `float64`; for inexact inputs, it is the same as the input</span>
<span class="sd">        dtype.</span>
<span class="sd">    out : BlockArray, optional</span>
<span class="sd">        Alternate output array in which to place the result.  The default</span>
<span class="sd">        is ``None``; if provided, it must have the same shape as the</span>
<span class="sd">        expected output, but the type will be cast if necessary.</span>
<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left</span>
<span class="sd">        in the result as dimensions with size one. With this option,</span>
<span class="sd">        the result will broadcast correctly against the original `a`.</span>
<span class="sd">        If the value is anything but the default, then</span>
<span class="sd">        `keepdims` will be passed through to the `mean` or `sum` methods</span>
<span class="sd">        of sub-classes of `BlockArray`.  If the sub-classes methods</span>
<span class="sd">        does not implement `keepdims` any exceptions will be raised.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    m : BlockArray, see dtype parameter above</span>
<span class="sd">        If `out=None`, returns a new array containing the mean values,</span>
<span class="sd">        otherwise a reference to the output array is returned. Nan is</span>
<span class="sd">        returned for slices that contain only NaNs.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    average : Weighted average</span>
<span class="sd">    mean : Arithmetic mean taken while not ignoring NaNs</span>
<span class="sd">    var, nanvar</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The arithmetic mean is the sum of the non-NaN elements along the axis</span>
<span class="sd">    divided by the number of non-NaN elements.</span>

<span class="sd">    Note that for floating-point input, the mean is computed using the same</span>
<span class="sd">    precision the input has.  Depending on the input data, this can cause</span>
<span class="sd">    the results to be inaccurate, especially for `float32`.  Specifying a</span>
<span class="sd">    higher-precision accumulator using the `dtype` keyword can alleviate</span>
<span class="sd">    this issue.</span>

<span class="sd">    &#39;out&#39; is currently not supported.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; a = nps.array([[1, nps.nan], [3, 4]])  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; nps.nanmean(a).get()  # doctest: +SKIP</span>
<span class="sd">    array(2.66666667)</span>
<span class="sd">    &gt;&gt;&gt; nps.nanmean(a, axis=0).get()  # doctest: +SKIP</span>
<span class="sd">    array([2.,  4.])</span>
<span class="sd">    &gt;&gt;&gt; nps.nanmean(a, axis=1).get()  # doctest: +SKIP</span>
<span class="sd">    array([1.,  3.5]) # may vary</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;&#39;out&#39; is currently not supported.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span></div>


<div class="viewcode-block" id="nanmin"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.nanmin.html#nums.numpy.api.nan.nanmin">[docs]</a><span class="k">def</span> <span class="nf">nanmin</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return minimum of an array or minimum along an axis, ignoring any NaNs.</span>
<span class="sd">    When all-NaN slices are encountered a ``RuntimeWarning`` is raised and</span>
<span class="sd">    Nan is returned for that slice.</span>

<span class="sd">    This docstring was copied from numpy.nanmin.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : BlockArray</span>
<span class="sd">        Array containing numbers whose minimum is desired. If `a` is not an</span>
<span class="sd">        array, a conversion is attempted.</span>
<span class="sd">    axis : {int, tuple of int, None}, optional</span>
<span class="sd">        Axis or axes along which the minimum is computed. The default is to compute</span>
<span class="sd">        the minimum of the flattened array.</span>
<span class="sd">    out : BlockArray, optional</span>
<span class="sd">        Alternate output array in which to place the result.  The default</span>
<span class="sd">        is ``None``; if provided, it must have the same shape as the</span>
<span class="sd">        expected output, but the type will be cast if necessary.</span>
<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left</span>
<span class="sd">        in the result as dimensions with size one. With this option,</span>
<span class="sd">        the result will broadcast correctly against the original `a`.</span>

<span class="sd">        If the value is anything but the default, then</span>
<span class="sd">        `keepdims` will be passed through to the `min` method</span>
<span class="sd">        of sub-classes of `BlockArray`.  If the sub-classes methods</span>
<span class="sd">        does not implement `keepdims` any exceptions will be raised.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    nanmin : BlockArray</span>
<span class="sd">        An array with the same shape as `a`, with the specified axis</span>
<span class="sd">        removed.  If `a` is a 0-d array, or if axis is None, an BlockArray</span>
<span class="sd">        scalar is returned.  The same dtype as `a` is returned.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    nanmax :</span>
<span class="sd">        The maximum value of an array along a given axis, ignoring any NaNs.</span>
<span class="sd">    amin :</span>
<span class="sd">        The minimum value of an array along a given axis, propagating any NaNs.</span>
<span class="sd">    fmin :</span>
<span class="sd">        Element-wise minimum of two arrays, ignoring any NaNs.</span>
<span class="sd">    minimum :</span>
<span class="sd">        Element-wise minimum of two arrays, propagating any NaNs.</span>
<span class="sd">    isnan :</span>
<span class="sd">        Shows which elements are Not a Number (NaN).</span>
<span class="sd">    isfinite:</span>
<span class="sd">        Shows which elements are neither NaN nor infinity.</span>

<span class="sd">    amax, fmax, maximum</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic</span>
<span class="sd">    (IEEE 754). This means that Not a Number is not equivalent to infinity.</span>
<span class="sd">    Positive infinity is treated as a very large number and negative</span>
<span class="sd">    infinity is treated as a very small (i.e. negative) number.</span>

<span class="sd">    If the input has a integer type the function is equivalent to nps.min.</span>

<span class="sd">    &#39;out&#39; is currently not supported.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; a = nps.array([[1, 2], [3, nps.nan]])  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; nps.nanmin(a).get()  # doctest: +SKIP</span>
<span class="sd">    arary(1.)</span>
<span class="sd">    &gt;&gt;&gt; nps.nanmin(a, axis=0).get()  # doctest: +SKIP</span>
<span class="sd">    array([1.,  2.])</span>
<span class="sd">    &gt;&gt;&gt; nps.nanmin(a, axis=1).get()  # doctest: +SKIP</span>
<span class="sd">    array([1.,  3.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;&#39;out&#39; is currently not supported.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="s2">&quot;nanmin&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span></div>


<div class="viewcode-block" id="nanstd"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.nanstd.html#nums.numpy.api.nan.nanstd">[docs]</a><span class="k">def</span> <span class="nf">nanstd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the standard deviation along the specified axis, while</span>
<span class="sd">    ignoring NaNs.</span>

<span class="sd">    This docstring was copied from numpy.nanstd.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Returns the standard deviation, a measure of the spread of a</span>
<span class="sd">    distribution, of the non-NaN array elements. The standard deviation is</span>
<span class="sd">    computed for the flattened array by default, otherwise over the</span>
<span class="sd">    specified axis.</span>

<span class="sd">    For all-NaN slices or slices with zero degrees of freedom, NaN is</span>
<span class="sd">    returned and a `RuntimeWarning` is raised.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : BlockArray</span>
<span class="sd">        Calculate the standard deviation of the non-NaN values.</span>
<span class="sd">    axis : {int, tuple of int, None}, optional</span>
<span class="sd">        Axis or axes along which the standard deviation is computed. The default is</span>
<span class="sd">        to compute the standard deviation of the flattened array.</span>
<span class="sd">    dtype : dtype, optional</span>
<span class="sd">        Type to use in computing the standard deviation. For arrays of</span>
<span class="sd">        integer type the default is float64, for arrays of float types it</span>
<span class="sd">        is the same as the array type.</span>
<span class="sd">    out : BlockArray, optional</span>
<span class="sd">        Alternative output array in which to place the result. It must have</span>
<span class="sd">        the same shape as the expected output but the type (of the</span>
<span class="sd">        calculated values) will be cast if necessary.</span>
<span class="sd">    ddof : int, optional</span>
<span class="sd">        Means Delta Degrees of Freedom.  The divisor used in calculations</span>
<span class="sd">        is ``N - ddof``, where ``N`` represents the number of non-NaN</span>
<span class="sd">        elements.  By default `ddof` is zero.</span>
<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left</span>
<span class="sd">        in the result as dimensions with size one. With this option,</span>
<span class="sd">        the result will broadcast correctly against the original `a`.</span>
<span class="sd">        If this value is anything but the default it is passed through</span>
<span class="sd">        as-is to the relevant functions of the sub-classes.  If these</span>
<span class="sd">        functions do not have a `keepdims` kwarg, a RuntimeError will</span>
<span class="sd">        be raised.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    standard_deviation : BlockArray, see dtype parameter above.</span>
<span class="sd">        If `out` is None, return a new array containing the standard</span>
<span class="sd">        deviation, otherwise return a reference to the output array. If</span>
<span class="sd">        ddof is &gt;= the number of non-NaN elements in a slice or the slice</span>
<span class="sd">        contains only NaNs, then the result for that slice is NaN.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    var, mean, std</span>
<span class="sd">    nanvar, nanmean</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The standard deviation is the square root of the average of the squared</span>
<span class="sd">    deviations from the mean: ``std = sqrt(mean(abs(x - x.mean())**2))``.</span>

<span class="sd">    The average squared deviation is normally calculated as</span>
<span class="sd">    ``x.sum() / N``, where ``N = len(x)``.  If, however, `ddof` is</span>
<span class="sd">    specified, the divisor ``N - ddof`` is used instead. In standard</span>
<span class="sd">    statistical practice, ``ddof=1`` provides an unbiased estimator of the</span>
<span class="sd">    variance of the infinite population. ``ddof=0`` provides a maximum</span>
<span class="sd">    likelihood estimate of the variance for normally distributed variables.</span>
<span class="sd">    The standard deviation computed in this function is the square root of</span>
<span class="sd">    the estimated variance, so even with ``ddof=1``, it will not be an</span>
<span class="sd">    unbiased estimate of the standard deviation per se.</span>

<span class="sd">    Note that, for complex numbers, `std` takes the absolute value before</span>
<span class="sd">    squaring, so that the result is always real and nonnegative.</span>

<span class="sd">    For floating-point input, the *std* is computed using the same</span>
<span class="sd">    precision the input has. Depending on the input data, this can cause</span>
<span class="sd">    the results to be inaccurate, especially for float32 (see example</span>
<span class="sd">    below).  Specifying a higher-accuracy accumulator using the `dtype`</span>
<span class="sd">    keyword can alleviate this issue.</span>

<span class="sd">    &#39;out&#39; is currently not supported&#39;</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; a = nps.array([[1, nps.nan], [3, 4]])  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; nps.nanstd(a).get()  # doctest: +SKIP</span>
<span class="sd">    array(1.24721913)</span>
<span class="sd">    &gt;&gt;&gt; nps.nanstd(a, axis=0).get()  # doctest: +SKIP</span>
<span class="sd">    array([1., 0.])</span>
<span class="sd">    &gt;&gt;&gt; nps.nanstd(a, axis=1).get()  # doctest: +SKIP</span>
<span class="sd">    array([0.,  0.5]) # may vary</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;&#39;out&#39; is currently not supported.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span></div>


<div class="viewcode-block" id="nansum"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.nansum.html#nums.numpy.api.nan.nansum">[docs]</a><span class="k">def</span> <span class="nf">nansum</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">BlockArray</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the sum of array elements over a given axis treating Not a</span>
<span class="sd">    Numbers (NaNs) as zero.</span>

<span class="sd">    This docstring was copied from numpy.nansum.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    In NumPy versions &lt;= 1.9.0 Nan is returned for slices that are all-NaN or</span>
<span class="sd">    empty. In later versions zero is returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : BlockArray</span>
<span class="sd">        Array containing numbers whose sum is desired. If `a` is not an</span>
<span class="sd">        array, a conversion is attempted.</span>
<span class="sd">    axis : {int, tuple of int, None}, optional</span>
<span class="sd">        Axis or axes along which the sum is computed. The default is to compute the</span>
<span class="sd">        sum of the flattened array.</span>
<span class="sd">    dtype : data-type, optional</span>
<span class="sd">        The type of the returned array and of the accumulator in which the</span>
<span class="sd">        elements are summed.  By default, the dtype of `a` is used.  An</span>
<span class="sd">        exception is when `a` has an integer type with less precision than</span>
<span class="sd">        the platform (u)intp. In that case, the default will be either</span>
<span class="sd">        (u)int32 or (u)int64 depending on whether the platform is 32 or 64</span>
<span class="sd">        bits. For inexact inputs, dtype must be inexact.</span>
<span class="sd">    out : BlockArray, optional</span>
<span class="sd">        Alternate output array in which to place the result.  The default</span>
<span class="sd">        is ``None``. If provided, it must have the same shape as the</span>
<span class="sd">        expected output, but the type will be cast if necessary.  See</span>
<span class="sd">        `ufuncs-output-type` for more details. The casting of NaN to integer</span>
<span class="sd">        can yield unexpected results.</span>
<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left</span>
<span class="sd">        in the result as dimensions with size one. With this option,</span>
<span class="sd">        the result will broadcast correctly against the original `a`.</span>
<span class="sd">        If the value is anything but the default, then</span>
<span class="sd">        `keepdims` will be passed through to the `mean` or `sum` methods</span>
<span class="sd">        of sub-classes of `BlockArray`.  If the sub-classes methods</span>
<span class="sd">        does not implement `keepdims` any exceptions will be raised.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    nansum : BlockArray.</span>
<span class="sd">        A new array holding the result is returned unless `out` is</span>
<span class="sd">        specified, in which it is returned. The result has the same</span>
<span class="sd">        size as `a`, and the same shape as `a` if `axis` is not None</span>
<span class="sd">        or `a` is a 1-d array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.sum : Sum across array propagating NaNs.</span>
<span class="sd">    isnan : Show which elements are NaN.</span>
<span class="sd">    isfinite: Show which elements are not NaN or +/-inf.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If both positive and negative infinity are present, the sum will be Not</span>
<span class="sd">    A Number (NaN).</span>

<span class="sd">    &#39;out&#39; is currently not supported.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; nps.nansum(nps.array([1])).get()  # doctest: +SKIP</span>
<span class="sd">    array(1)</span>
<span class="sd">    &gt;&gt;&gt; nps.nansum(nps.array([1, nps.nan])).get()  # doctest: +SKIP</span>
<span class="sd">    array(1.)</span>
<span class="sd">    &gt;&gt;&gt; a = nps.array([[1, 1], [1, nps.nan]])  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; nps.nansum(a).get()  # doctest: +SKIP</span>
<span class="sd">    array(3.)</span>
<span class="sd">    &gt;&gt;&gt; nps.nansum(a, axis=0).get()  # doctest: +SKIP</span>
<span class="sd">    array([2.,  1.])</span>
<span class="sd">    &gt;&gt;&gt; nps.nansum(nps.array([1, nps.nan, nps.inf])).get()  # doctest: +SKIP</span>
<span class="sd">    array(inf)</span>
<span class="sd">    &gt;&gt;&gt; nps.nansum(nps.array([1, nps.nan, nps.NINF])).get()  # doctest: +SKIP</span>
<span class="sd">    array(-inf)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;&#39;out&#39; is currently not supported.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="s2">&quot;nansum&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span></div>


<div class="viewcode-block" id="nanvar"><a class="viewcode-back" href="../../../../reference/generated/nums.numpy.nanvar.html#nums.numpy.api.nan.nanvar">[docs]</a><span class="k">def</span> <span class="nf">nanvar</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the variance along the specified axis, while ignoring NaNs.</span>

<span class="sd">    This docstring was copied from numpy.nanvar.</span>

<span class="sd">    Some inconsistencies with the NumS version may exist.</span>

<span class="sd">    Returns the variance of the array elements, a measure of the spread of</span>
<span class="sd">    a distribution.  The variance is computed for the flattened array by</span>
<span class="sd">    default, otherwise over the specified axis.</span>

<span class="sd">    For all-NaN slices or slices with zero degrees of freedom, NaN is</span>
<span class="sd">    returned and a `RuntimeWarning` is raised.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : BlockArray</span>
<span class="sd">        Array containing numbers whose variance is desired.  If `a` is not an</span>
<span class="sd">        array, a conversion is attempted.</span>
<span class="sd">    axis : {int, tuple of int, None}, optional</span>
<span class="sd">        Axis or axes along which the variance is computed.  The default is to compute</span>
<span class="sd">        the variance of the flattened array.</span>
<span class="sd">    dtype : data-type, optional</span>
<span class="sd">        Type to use in computing the variance.  For arrays of integer type</span>
<span class="sd">        the default is `float64`; for arrays of float types it is the same as</span>
<span class="sd">        the array type.</span>
<span class="sd">    out : BlockArray, optional</span>
<span class="sd">        Alternate output array in which to place the result.  It must have</span>
<span class="sd">        the same shape as the expected output, but the type is cast if</span>
<span class="sd">        necessary.</span>
<span class="sd">    ddof : int, optional</span>
<span class="sd">        &quot;Delta Degrees of Freedom&quot;: the divisor used in the calculation is</span>
<span class="sd">        ``N - ddof``, where ``N`` represents the number of non-NaN</span>
<span class="sd">        elements. By default `ddof` is zero.</span>
<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left</span>
<span class="sd">        in the result as dimensions with size one. With this option,</span>
<span class="sd">        the result will broadcast correctly against the original `a`.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    variance : BlockArray, see dtype parameter above</span>
<span class="sd">        If `out` is None, return a new array containing the variance,</span>
<span class="sd">        otherwise return a reference to the output array. If ddof is &gt;= the</span>
<span class="sd">        number of non-NaN elements in a slice or the slice contains only</span>
<span class="sd">        NaNs, then the result for that slice is NaN.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    std : Standard deviation</span>
<span class="sd">    mean : Average</span>
<span class="sd">    var : Variance while not ignoring NaNs</span>
<span class="sd">    nanstd, nanmean</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The variance is the average of the squared deviations from the mean,</span>
<span class="sd">    i.e.,  ``var = mean(abs(x - x.mean())**2)``.</span>

<span class="sd">    The mean is normally calculated as ``x.sum() / N``, where ``N = len(x)``.</span>
<span class="sd">    If, however, `ddof` is specified, the divisor ``N - ddof`` is used</span>
<span class="sd">    instead.  In standard statistical practice, ``ddof=1`` provides an</span>
<span class="sd">    unbiased estimator of the variance of a hypothetical infinite</span>
<span class="sd">    population.  ``ddof=0`` provides a maximum likelihood estimate of the</span>
<span class="sd">    variance for normally distributed variables.</span>

<span class="sd">    Note that for complex numbers, the absolute value is taken before</span>
<span class="sd">    squaring, so that the result is always real and nonnegative.</span>

<span class="sd">    For floating-point input, the variance is computed using the same</span>
<span class="sd">    precision the input has.  Depending on the input data, this can cause</span>
<span class="sd">    the results to be inaccurate, especially for `float32` (see example</span>
<span class="sd">    below).  Specifying a higher-accuracy accumulator using the ``dtype``</span>
<span class="sd">    keyword can alleviate this issue.</span>

<span class="sd">    For this function to work on sub-classes of BlockArray, they must define</span>
<span class="sd">    `sum` with the kwarg `keepdims`</span>

<span class="sd">    &#39;out&#39; is currently not supported.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The doctests shown below are copied from NumPy.</span>
<span class="sd">    They won’t show the correct result until you operate ``get()``.</span>

<span class="sd">    &gt;&gt;&gt; a = nps.array([[1, nps.nan], [3, 4]])  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; nps.nanvar(a).get()  # doctest: +SKIP</span>
<span class="sd">    array(1.55555556)</span>
<span class="sd">    &gt;&gt;&gt; nps.nanvar(a, axis=0).get()  # doctest: +SKIP</span>
<span class="sd">    array([1.,  0.])</span>
<span class="sd">    &gt;&gt;&gt; nps.nanvar(a, axis=1).get()  # doctest: +SKIP</span>
<span class="sd">    array([0.,  0.25])  # may vary</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;&#39;out&#39; is currently not supported.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_instance</span><span class="p">()</span><span class="o">.</span><span class="n">nanvar</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span></div>
</pre></div>

              </div>
              
              
              <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
              
          </main>
          

      </div>
    </div>
  
    <script src="../../../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>
  <footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2022, The NumS Team.<br>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.5.4.<br>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>